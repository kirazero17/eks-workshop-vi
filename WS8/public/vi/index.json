[
{
	"uri": "/vi/1-introduce/1.1-docker-storage/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu về Lưu trữ Docker Trong phần này, chúng ta sẽ tìm hiểu về lưu trữ Docker.\nĐể hiểu lưu trữ trong các công cụ điều phối container như Kubernetes, điều quan trọng là hiểu rõ cách lưu trữ hoạt động với các container trước. Hiểu cách lưu trữ hoạt động với Docker trước tiên và làm cho tất cả các khái niệm cơ bản đúng sẽ làm cho việc hiểu cách nó hoạt động trong Kubernetes dễ dàng hơn nhiều sau này.\nNếu bạn mới bắt đầu với Docker thì bạn có thể học một số khái niệm cơ bản của docker từ khóa học Docker cho người mới bắt đầu, miễn phí.\nLưu trữ Docker Có hai khái niệm liên quan đến Docker, đó là các trình điều khiển lưu trữ và các plugin trình điều khiển thư mục. Chúng ta sẽ trước tiên thảo luận về các trình điều khiển lưu trữ. Tài liệu Tham khảo Docker https://docs.docker.com/storage/storagedriver/ https://docs.docker.com/storage/volumes/ "
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Hiểu về mạng trong Kubernetes Hiểu về mạng trong Kubernetes là vô cùng quan trọng để vận hành cụm và ứng dụng của bạn một cách hiệu quả. Trong chương này, chúng ta sẽ đào sâu vào các khía cạnh khác nhau của mạng trong Kubernetes, bao gồm mạng Pod, mạng dịch vụ, và giao tiếp dịch vụ.\nTrong Amazon EKS, mạng Pod, còn được gọi là mạng cụm, được giải quyết thông qua việc sử dụng một plugin CNI của Kubernetes gọi là Amazon VPC CNI. Chúng tôi rất khuyến khích khám phá các tùy chọn khác nhau có sẵn với Amazon VPC CNI trước khi chuyển sang Amazon VPC Lattice.\nCác phần cần tìm hiểu Switching, Routing and Gateways Switching Routing Default Gateway DNS DNS Configuration on Linux CoreDNS Network Namespace Docker Networking CNI Cluster Networking Pod Networking CNI in Kubernetes CoreDNS Ingress "
},
{
	"uri": "/vi/",
	"title": "Kubernetes trên AWS",
	"tags": [],
	"description": "",
	"content": "Kubernetes trên AWS Kubernetes là một nền tảng mã nguồn mở, linh hoạt, có khả năng mở rộng, phục vụ việc quản lý các ứng dụng được đóng gói và các dịch vụ liên quan, giúp việc cấu hình và tự động hóa quá trình triển khai ứng dụng trở nên thuận tiện hơn. Được biết đến như một hệ sinh thái lớn và phát triển nhanh chóng, Kubernetes cung cấp sự hỗ trợ rộng rãi qua các dịch vụ và công cụ đa dạng.\nTên Kubernetes bắt nguồn từ tiếng Hy Lạp, nghĩa là người lái tàu hoặc hoa tiêu. Kubernetes được Google công bố mã nguồn vào năm 2014, dựa trên gần một thập kỷ kinh nghiệm quản lý workload lớn trong thực tế của Google, kết hợp với các ý tưởng và best practices từ cộng đồng.\nQuay ngược thời gian Hãy xem xét tại sao Kubernetes lại quan trọng thông qua việc nhìn lại quá khứ.\nThời kỳ triển khai truyền thống: Ban đầu, các ứng dụng được chạy trực tiếp trên máy chủ vật lý, khiến việc phân bổ tài nguyên gặp khó khăn do không có cơ chế xác định ranh giới tài nguyên cho từng ứng dụng. Cách tiếp cận này dẫn đến nguy cơ một ứng dụng có thể sử dụng quá nhiều tài nguyên, ảnh hưởng đến hoạt động của các ứng dụng khác. Giải pháp là chạy mỗi ứng dụng trên một máy chủ vật lý riêng biệt, nhưng điều này lại không hiệu quả về mặt chi phí và tài nguyên.\nThời kỳ triển khai ảo hóa: Ảo hóa được giới thiệu như một giải pháp cho phép chạy nhiều Máy ảo (VM) trên cùng một máy chủ vật lý, giúp cô lập ứng dụng và tăng cường bảo mật. Ảo hóa cũng giúp cải thiện hiệu quả sử dụng tài nguyên và khả năng mở rộng.\nThời kỳ triển khai Container: Container giống như VM nhưng nhẹ hơn và chia sẻ Hệ điều hành (HĐH) với nhau. Container mang lại nhiều lợi ích như tạo mới và triển khai ứng dụng nhanh chóng, phát triển và triển khai liên tục, phân biệt rõ ràng giữa quá trình phát triển và vận hành, cung cấp tính nhất quán qua các môi trường, khả năng di chuyển giữa các cloud và HĐH, và quản lý ứng dụng tập trung.\nTại sao bạn cần Kubernetes và nó có thể làm gì? Container là phương tiện hiệu quả để đóng gói và chạy ứng dụng của bạn. Trong môi trường sản xuất, cần có cơ chế quản lý các container một cách hiệu quả, đảm bảo không có downtime. Kubernetes giúp quản lý các hệ thống phân tán mạnh mẽ, tự động hóa việc nhân rộng, cung cấp các mẫu triển khai và nhiều hơn nữa.\nKubernetes mang lại:\nPhát hiện dịch vụ và cân bằng tải Điều phối bộ nhớ Tự động rollouts và rollbacks Đóng gói tự động Tự phục hồi Quản lý cấu hình và bảo mật Những gì Kubernetes không phải là Kubernetes không phải là một hệ thống PaaS truyền thống, toàn diện. Nó hoạt động ở tầng container, cung cấp tính năng giống như PaaS như triển khai, nhân rộng, cân bằng tải, nhưng là một giải pháp linh hoạt và có thể mở rộng, không giới hạn loại ứng dụng được hỗ trợ, không triển khai mã nguồn hoặc build ứng dụng, không cung cấp dịch vụ ứng dụng cấp cao như middleware, databases, không bắt buộc sử dụng các giải pháp ghi nhật ký, giám sát hoặc cảnh báo, và không cung cấp hoặc áp dụng bất kỳ cấu hình toàn diện, bảo trì, quản lý hoặc hệ thống tự phục hồi. Kubernetes loại bỏ nhu cầu về điều phối truyền thống, thay vào đó là kiểm soát liên tục từ trạng thái hiện tại sang trạng thái mong muốn.\n"
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Lưu trữ trên EKS Storage on EKS sẽ cung cấp một cái nhìn tổng quan về cách tích hợp hai dịch vụ Lưu trữ của AWS với cụm EKS của bạn.\nTrước khi chúng ta đào sâu vào việc triển khai, dưới đây là một tóm tắt về hai dịch vụ lưu trữ của AWS mà chúng ta sẽ sử dụng và tích hợp với EKS:\nAmazon Elastic Block Store (hỗ trợ EC2): một dịch vụ lưu trữ khối cung cấp truy cập trực tiếp từ các trường hợp EC2 và container đến một ổ lưu trữ được thiết kế cho cả hiệu suất và khối lượng công việc giao dịch ở bất kỳ quy mô nào. Amazon Elastic File System (hỗ trợ Fargate và EC2): một hệ thống tệp được quản lý hoàn toàn, có khả năng mở rộng và đàn hồi phù hợp cho phân tích dữ liệu lớn, phục vụ web và quản lý nội dung, phát triển và kiểm thử ứng dụng, quy trình công việc phương tiện và giải trí, sao lưu cơ sở dữ liệu và lưu trữ container. EFS lưu trữ dữ liệu của bạn một cách dự phòng trên nhiều Khu vực Khả dụng (AZ) và cung cấp truy cập độ trễ thấp từ các pod Kubernetes bất kể AZ chúng đang chạy ở. Amazon FSx for NetApp ONTAP (hỗ trợ EC2): Lưu trữ chia sẻ được quản lý hoàn toàn dựa trên hệ thống tệp ONTAP phổ biến của NetApp. FSx cho NetApp ONTAP lưu trữ dữ liệu của bạn một cách dự phòng trên nhiều Khu vực Khả dụng (AZ) và cung cấp truy cập độ trễ thấp từ các pod Kubernetes bất kể AZ chúng đang chạy ở. FSx for Lustre (hỗ trợ EC2): một hệ thống tệp hoàn toàn được quản lý, hiệu suất cao được tối ưu hóa cho các khối công việc như học máy, tính toán hiệu suất cao, xử lý video, mô hình tài chính, tự động hóa thiết kế điện tử và phân tích. Với FSx cho Lustre, bạn có thể nhanh chóng tạo ra một hệ thống tệp hiệu suất cao liên kết với kho lưu trữ dữ liệu S3 của bạn và truy cập các đối tượng S3 một cách trong suốt như các tệp. FSx sẽ được thảo luận trong các module tương lai của workshop này Quan trọng hơn cả là nắm vững một số khái niệm về Lưu trữ Kubernetes:\nVolumes: Các tệp trên đĩa trong một container là tạm thời, điều này đặt ra một số vấn đề đối với các ứng dụng phức tạp khi chạy trong các container. Một vấn đề là mất các tệp khi một container gặp sự cố. Kubelet khởi động lại container nhưng với một trạng thái sạch sẽ. Một vấn đề thứ hai xảy ra khi chia sẻ tệp giữa các container chạy cùng nhau trong một Pod. Trừu tượng hóa khối lưu trữ Kubernetes giải quyết cả hai vấn đề này. Việc quen thuộc với Pods được đề xuất. Ephemeral Volumes được thiết kế cho các trường hợp sử dụng này. Vì các khối lưu trữ tuân theo vòng đời của Pod và được tạo ra và xóa cùng với Pod, Pods có thể bị dừng lại và khởi động lại mà không bị giới hạn ở nơi mà một số khối lưu trữ lâu dài có sẵn. Persistent Volumes (PV) là một phần của lưu trữ trong một cụm đã được cung cấp bởi một quản trị viên hoặc được cung cấp động bằng cách sử dụng Lớp Lưu trữ. Đó là một tài nguyên trong cụm giống như một nút là một tài nguyên của cụm. PVs là plugin khối lưu trữ giống như Volumes, nhưng có vòng đời độc lập với bất kỳ Pod cụ thể nào sử dụng PV. Đối tượng API này ghi lại các chi tiết của việc triển khai lưu trữ, có thể là NFS, iSCSI hoặc hệ thống lưu trữ cụ thể của nhà cung cấp đám mây. "
},
{
	"uri": "/vi/1-introduce/1.2-storage/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Lưu trữ trong Docker Trong phần này, chúng ta sẽ xem xét Driver Lưu trữ và Hệ thống tệp của Docker.\nChúng ta sẽ xem xét nơi và cách Docker lưu trữ dữ liệu và cách quản lý hệ thống tệp của các container. Hệ thống tệp Hãy xem cách Docker lưu trữ dữ liệu trên hệ thống tệp cục bộ. Lần đầu tiên, khi bạn cài đặt Docker trên một hệ thống, nó tạo ra cấu trúc thư mục này tại /var/lib/docker.\n$ cd /var/lib/docker/ Bạn có nhiều thư mục con dưới đó gọi là aufs, containers, image, volumes, vv. Đây là nơi mà Docker lưu trữ tất cả dữ liệu của nó theo mặc định. Tất cả các tệp liên quan đến các container được lưu trữ dưới thư mục containers và các tệp liên quan đến các hình ảnh được lưu trữ dưới thư mục image. Bất kỳ thư mục nào được tạo bởi các container Docker đều được tạo dưới thư mục volumes. Bây giờ, hãy chỉ hiểu nơi Docker lưu trữ các tệp của hình ảnh và một container và định dạng nào. Để hiểu điều đó, chúng ta cần hiểu về kiến ​​trúc lớp của Docker. Kiến ​​trúc lớp Khi Docker xây dựng hình ảnh, nó xây dựng chúng trong một kiến ​​trúc lớp. Mỗi dòng lệnh trong tệp Docker tạo một lớp mới trong hình ảnh Docker chỉ với các thay đổi từ lớp trước đó. Như bạn có thể thấy trong hình ảnh, lớp-1 là lớp cơ sở Ubuntu, lớp-2 cài đặt các gói, lớp-3 cài đặt các gói Python, lớp-4 cập nhật mã nguồn, lớp-5 cập nhật điểm vào của hình ảnh. Khi mỗi lớp chỉ lưu trữ các thay đổi từ lớp trước đó. Nó cũng được phản ánh trong kích thước. Để hiểu rõ hơn về các ưu điểm của kiến ​​trúc lớp này, hãy xem một Dockerfile khác, điều này rất giống với ứng dụng đầu tiên của chúng tôi. chỉ mã nguồn và điểm vào là khác nhau để tạo ra ứng dụng này. Khi hình ảnh được xây dựng, Docker sẽ không xây dựng ba lớp đầu tiên mà thay vào đó sẽ sử dụng lại ba lớp giống như các lớp đã xây dựng cho ứng dụng đầu tiên từ bộ nhớ cache. Chỉ tạo ra hai lớp cuối cùng với nguồn và điểm vào mới. Như vậy, Docker xây dựng hình ảnh nhanh chóng và hiệu quả tiết kiệm không gian đĩa. Điều này cũng áp dụng nếu bạn muốn cập nhật mã ứng dụng của mình. Docker đơn giản là sử dụng lại tất cả các lớp trước đó từ bộ nhớ cache và nhanh chóng xây dựng lại hình ảnh ứng dụng bằng cách cập nhật mã nguồn mới nhất. Hãy sắp xếp lại các lớp từ dưới lên để chúng ta có thể hiểu rõ hơn. Tất cả các lớp này được tạo ra khi chúng ta chạy lệnh Docker build để hình thành hình ảnh Docker cuối cùng. Khi quá trình xây dựng hoàn tất, bạn không thể chỉnh sửa nội dung của các lớp này và vì vậy chúng là chỉ đọc và bạn chỉ có thể chỉnh sửa chúng bằng cách khởi tạo một quá trình xây dựng mới. Khi bạn chạy một container dựa trên hình ảnh này, bằng cách sử dụng lệnh Docker run Docker tạo ra một container dựa trên các lớp này và tạo ra một lớp có thể ghi mới trên lớp hình ảnh. Lớp có thể ghi được sử dụng để lưu trữ dữ liệu được tạo ra bởi container như các tệp nhật ký được viết bởi các ứng dụng, bất kỳ tệp tạm thời nào được tạo ra bởi container. Khi container bị hủy, lớp này và tất cả các thay đổi được lưu trữ trong đó cũng bị hủy. Hãy nhớ rằng cùng một lớp hình ảnh được chia sẻ bởi tất c "
},
{
	"uri": "/vi/1-introduce/1.3-volume-driver-plugins-in-docker/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Plugin Volume Driver trong Docker Điều hướng tới Bài giảng Trong phần này, chúng ta sẽ tìm hiểu về Plugin Volume Driver trong Docker\nChúng ta đã thảo luận về các driver lưu trữ. Các driver lưu trữ giúp quản lý lưu trữ trên hình ảnh và container. Chúng ta đã biết rằng nếu bạn muốn lưu trữ lâu dài, bạn phải tạo ra các thùng chứa. Các thùng chứa không được quản lý bởi các driver lưu trữ. Các thùng chứa được quản lý bởi các plugin driver thùng chứa. Plugin driver thùng chứa mặc định là local. Plugin thùng chứa local giúp tạo ra một thùng chứa trên máy chủ Docker và lưu trữ dữ liệu của nó dưới thư mục /var/lib/docker/volumes/. Có nhiều plugin driver thùng chứa khác cho phép bạn tạo ra một thùng chứa trên các giải pháp của bên thứ ba như lưu trữ tệp Azure, Lưu trữ khối DigitalOcean, Portworx, Đĩa cố định Google Compute, v.v. Khi bạn chạy một container Docker, bạn có thể chọn sử dụng một plugin driver thùng chứa cụ thể, như RexRay EBS để cung cấp một thùng chứa từ Amazon EBS. Điều này sẽ tạo ra một container và gắn kết một thùng chứa từ điện toán đám mây AWS. Khi container kết thúc, dữ liệu của bạn được an toàn trên điện toán đám mây. $ docker run -it --name mysql --volume-driver rexray/ebs --mount src=ebs-vol,target=/var/lib/mysql mysql Tài liệu tham khảo Docker https://docs.docker.com/engine/extend/legacy_plugins/ https://github.com/rexray/rexray "
},
{
	"uri": "/vi/1-introduce/1.4-container-storage-interface/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giao diện Lưu trữ Container Trong phần này, chúng ta sẽ tìm hiểu về Giao diện Lưu trữ Container.\nGiao diện Thực thi Container Kubernetes sử dụng Docker một mình làm động cơ thực thi container, và toàn bộ mã để làm việc với Docker được nhúng trong mã nguồn Kubernetes. Các động cơ thực thi container khác, như rkt và CRI-O. Giao diện Thực thi Container là một tiêu chuẩn xác định cách một giải pháp điều phối như Kubernetes sẽ giao tiếp với các động cơ thực thi container như Docker. Nếu bất kỳ giao diện thực thi container mới nào được phát triển, họ có thể đơn giản là tuân thủ các tiêu chuẩn CRI. Giao diện Mạng Container Để hỗ trợ các giải pháp mạng khác nhau, giao diện mạng container được giới thiệu. Bất kỳ nhà cung cấp mạng lưới mới nào cũng có thể đơn giản phát triển plugin của họ dựa trên các tiêu chuẩn CNI và làm cho giải pháp của họ hoạt động với Kubernetes. Giao diện Lưu trữ Container Giao diện lưu trữ container được phát triển để hỗ trợ nhiều giải pháp lưu trữ. Với CSI, bạn hiện có thể viết các trình điều khiển của riêng mình cho lưu trữ của riêng bạn để hoạt động với Kubernetes. Portworx, Amazon EBS, Ảo Disk Azure, GlusterFS vv. CSI không phải là một tiêu chuẩn cụ thể của Kubernetes. Nó được thiết kế để là một tiêu chuẩn phổ quát và nếu triển khai, cho phép bất kỳ công cụ điều phối container nào làm việc với bất kỳ nhà cung cấp lưu trữ nào có plugin được hỗ trợ. Kubernetes, Cloud Foundry và Mesos đều tham gia với CSI. Nó xác định một tập hợp các RPC hoặc cuộc gọi thủ tục từ xa sẽ được gọi bởi trình điều phối container. Các trình điều khiển lưu trữ phải triển khai các RPC này. Giao diện Lưu trữ Container https://github.com/container-storage-interface/spec https://kubernetes-csi.github.io/docs/ http://mesos.apache.org/documentation/latest/csi/ https://www.nomadproject.io/docs/internals/plugins/csi#volume-lifecycle "
},
{
	"uri": "/vi/1-introduce/1.5-volumes/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tích Hợp Ổ Đĩa (Volumes) Trong phần này, chúng ta sẽ xem xét về Tích Hợp Ổ Đĩa (Volumes)\nChúng ta đã thảo luận về lưu trữ Docker, Nếu chúng ta không gắn kết ổ đĩa vào thời gian chạy container, khi container bị hủy và sau đó tất cả dữ liệu sẽ bị mất. Vì vậy, chúng ta cần lưu trữ dữ liệu vào bên trong container Docker để đính kèm một ổ đĩa cho các container khi chúng được tạo ra.\nDữ liệu được xử lý bởi container hiện đang được đặt trong ổ đĩa này, giữ nó vĩnh viễn. Ngay cả khi container bị xóa, dữ liệu vẫn tồn tại trong ổ đĩa.\nTrong thế giới Kubernetes, các POD được tạo ra trong Kubernetes có tính chất tạm thời. Khi một POD được tạo ra để xử lý dữ liệu và sau đó bị xóa, dữ liệu được xử lý bởi nó cũng bị xóa đi.\nVí dụ, chúng ta tạo ra một POD đơn giản tạo ra một số ngẫu nhiên từ 1 đến 100 và ghi nó vào một tệp tại /opt/number.out. Để lưu trữ vào ổ đĩa.\nChúng ta tạo ra một ổ đĩa cho điều đó. Trong trường hợp này, tôi chỉ định một đường dẫn /data trên máy chủ. Các tệp được lưu trữ trong thư mục data trên nút của tôi. Chúng ta sử dụng trường volumeMounts trong mỗi container để gắn ổ đĩa dữ liệu vào thư mục /opt bên trong container. Số ngẫu nhiên sẽ được ghi vào /opt mount bên trong container, đó cũng là ổ đĩa dữ liệu nằm trong thư mục /data trên máy chủ thực tế. Khi POD bị xóa, tệp chứa số ngẫu nhiên vẫn còn tồn tại trên máy chủ.\nCác Lựa Chọn Lưu Trữ Ổ Đĩa Trong các ổ đĩa, loại ổ đĩa hostPath là tốt cho một nút duy nhất. Nó không được khuyến nghị sử dụng trong các cụm nhiều nút. Trong Kubernetes, nó hỗ trợ một số loại giải pháp lưu trữ tiêu chuẩn như NFS, GlusterFS, CephFS hoặc các giải pháp đám mây công cộng như AWS EBS, Azure Disk hoặc Google\u0026rsquo;s Persistent Disk. volumes:\r- name: data-volume\rawsElasticBlockStore:\rvolumeID: \u0026lt;volume-id\u0026gt;\rfsType: ext4 Tài Liệu Tham Khảo Ổ Đĩa Kubernetes https://kubernetes.io/docs/concepts/storage/volumes/ https://kubernetes.io/docs/tasks/configure-pod-container/configure-volume-storage/ https://unofficial-kubernetes.readthedocs.io/en/latest/concepts/storage/volumes/ https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#volume-v1-core "
},
{
	"uri": "/vi/1-introduce/1.6-persistent-volumes/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Khối Lưu Trữ Cố Định Điều hướng đến Bài Giảng Trong phần này, chúng ta sẽ xem xét về Khối Lưu Trữ Cố Định\nTrong môi trường lớn, với nhiều người dùng triển khai nhiều pods, người dùng sẽ phải cấu hình lưu trữ mỗi lần cho mỗi Pod. Bất kể giải pháp lưu trữ nào được sử dụng, người dùng triển khai các pods sẽ phải cấu hình chúng trên tất cả các tệp định nghĩa pods trong môi trường của mình. Mỗi khi có thay đổi, người dùng sẽ phải thực hiện chúng trên tất cả các pods của mình. Một Khối Lưu Trữ Cố Định là một cụm lưu trữ trên toàn cụm được cấu hình bởi một quản trị viên để được sử dụng bởi người dùng triển khai ứng dụng trên cụm. Người dùng có thể lựa chọn lưu trữ từ cụm này bằng cách sử dụng các Yêu Cầu Khối Lưu Trữ Cố Định.\npv-definition.yaml kind: PersistentVolume apiVersion: v1 metadata: name: pv-vol1 spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] capacity: storage: 1Gi hostPath: path: /tmp/data $ kubectl create -f pv-definition.yaml persistentvolume/pv-vol1 created $ kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pv-vol1 1Gi RWO Retain Available 3min $ kubectl delete pv pv-vol1 persistentvolume \u0026#34;pv-vol1\u0026#34; deleted Khối Lưu Trữ Cố Định Kubernetes https://kubernetes.io/docs/concepts/storage/persistent-volumes/ https://portworx.com/tutorial-kubernetes-persistent-volumes/ "
},
{
	"uri": "/vi/1-introduce/1.7-persistent-volume-claims/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Yêu cầu Khối Lưu Trữ Đưa tôi đến Bài giảng Trong phần này, chúng ta sẽ xem xét Yêu cầu Khối Lưu Trữ\nBây giờ chúng ta sẽ tạo một Yêu cầu Khối Lưu Trữ để làm cho lưu trữ có sẵn cho node. Khối Lưu Trữ và Yêu cầu Khối Lưu Trữ là hai đối tượng riêng biệt trong không gian tên Kubernetes. Khi Yêu cầu Khối Lưu Trữ được tạo, Kubernetes sẽ gán các Khối Lưu Trữ vào yêu cầu dựa trên yêu cầu và thuộc tính được thiết lập trên khối. Nếu các thuộc tính không khớp hoặc Khối Lưu Trữ không có sẵn cho Yêu cầu Khối Lưu Trữ thì nó sẽ hiển thị trạng thái đang chờ. pvc-definition.yaml kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi pv-definition.yaml kind: PersistentVolume apiVersion: v1 metadata: name: pv-vol1 spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] capacity: storage: 1Gi hostPath: path: /tmp/data Tạo Khối Lưu Trữ $ kubectl create -f pv-definition.yaml\rpersistentvolume/pv-vol1 đã được tạo\r$ kubectl get pv\rNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE\rpv-vol1 1Gi RWO Retain Available 10s Tạo Yêu Cầu Khối Lưu Trữ $ kubectl create -f pvc-definition.yaml\rpersistentvolumeclaim/myclaim đã được tạo\r$ kubectl get pvc\rNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyclaim Pending 35s\r$ kubectl get pvc\rNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyclaim Bound pv-vol1 1Gi RWO 1min Xóa Yêu Cầu Khối Lưu Trữ $ kubectl delete pvc myclaim Xóa Khối Lưu Trữ $ kubectl delete pv pv-vol1 Tài liệu Tham Khảo về Yêu Cầu Khối Lưu Trữ Kubernetes https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#persistentvolumeclaim-v1-core https://docs.cloud.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengcreatingpersistentvolumeclaim.htm "
},
{
	"uri": "/vi/1-introduce/1.8-using-pvc-in-pods/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Sử dụng PVC trong PODs Đi đến Bài giảng Trong phần này, chúng ta sẽ tìm hiểu về Sử dụng PVC trong PODs\nTrong trường hợp này, PODs truy cập vào bộ nhớ lưu trữ bằng cách sử dụng yêu cầu làm một khối. Persistent Volume Claim phải tồn tại trong cùng namespace với Pod sử dụng yêu cầu. Cụm sẽ tìm thấy yêu cầu trong namespace của Pod và sử dụng nó để lấy Persistent Volume hậu bổng yêu cầu. Khối sau đó được gắn vào máy chủ và vào Pod. Persistent Volume là phạm vi của cụm và Persistent Volume Claim là phạm vi của namespace. Tạo Persistent Volume pv-definition.yaml kind: PersistentVolume apiVersion: v1 metadata: name: pv-vol1 spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] capacity: storage: 1Gi hostPath: path: /tmp/data $ kubectl create -f pv-definition.yaml Tạo Persistent Volume Claim pvc-definition.yaml kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi $ kubectl create -f pvc-definition.yaml Tạo một Pod pod-definition.yaml apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: myfrontend image: nginx volumeMounts: - mountPath: \u0026#34;/var/www/html\u0026#34; name: web volumes: - name: web persistentVolumeClaim: claimName: myclaim $ kubectl create -f pod-definition.yaml Liệt kê các Pod, Persistent Volume và Persistent Volume Claim $ kubectl get pod,pvc,pv Tài liệu tham khảo https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes "
},
{
	"uri": "/vi/1-introduce/1.9-storage-class/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Lớp Lưu Trữ Trong phần này, chúng ta sẽ xem xét về Lớp Lưu Trữ\nChúng ta đã thảo luận về cách tạo Volume Bền Vững và Yêu Cầu Volume Bền Vững và Chúng ta cũng đã thấy cách sử dụng vào không gian Volume của Pod để yêu cầu không gian volume đó. Chúng ta đã tạo Volume Bền Vững nhưng trước khi điều này nếu chúng ta đang lấy một volume từ các nhà cung cấp Đám Mây như GCP, AWS, Azure. Chúng ta cần phải tạo ổ đĩa trong Google Cloud là một ví dụ. Chúng ta cần phải tạo thủ công mỗi khi khi chúng ta định nghĩa trong tệp định nghĩa Pod. Điều này được gọi là Cung Cấp Tĩnh. Cung Cấp Tĩnh Cung Cấp Động Bây giờ chúng ta có một Lớp Lưu Trữ, Vì vậy chúng ta không cần phải định nghĩa Volume Bền Vững nữa. Nó sẽ được tạo tự động khi một Lớp Lưu Trữ được tạo. Điều này được gọi là Cung Cấp Động. sc-definition.yaml\rapiVersion: storage.k8s.io/v1\rkind: StorageClass\rmetadata:\rname: google-storage\rprovisioner: kubernetes.io/gce-pd Tạo Một Lớp Lưu Trữ $ kubectl create -f sc-definition.yaml\rstorageclass.storage.k8s.io/google-storage created Liệt Kê Các Lớp Lưu Trữ $ kubectl get sc\rNAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE\rgoogle-storage kubernetes.io/gce-pd Delete Immediate false 20s Tạo Yêu Cầu Volume Bền Vững pvc-definition.yaml\rkind: PersistentVolumeClaim\rapiVersion: v1\rmetadata:\rname: myclaim\rspec:\raccessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ]\rstorageClassName: google-storage resources:\rrequests:\rstorage: 500Mi $ kubectl create -f pvc-definition.yaml Tạo Một Pod pod-definition.yaml\rapiVersion: v1\rkind: Pod\rmetadata:\rname: mypod\rspec:\rcontainers:\r- name: frontend\rimage: nginx\rvolumeMounts:\r- mountPath: \u0026#34;/var/www/html\u0026#34;\rname: web\rvolumes:\r- name: web\rpersistentVolumeClaim:\rclaimName: myclaim $ kubectl create -f pod-definition.yaml Người Cung Cấp Tài liệu Tham Khảo Lớp Lưu Trữ Kubernetes https://kubernetes.io/docs/concepts/storage/storage-classes/ https://cloud.google.com/kubernetes-engine/docs/concepts/persistent-volumes#storageclasses https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]