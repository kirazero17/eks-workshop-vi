[
{
	"uri": "/vi/3-ebs/3.1-statefulsets/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Các Bước Chuẩn Bị Tương tự như Deployments, StatefulSets quản lý các Pods dựa trên một container spec đồng nhất. Khác với Deployments, StatefulSets duy trì một danh tính cố định cho mỗi Pod của nó. Các Pods này được tạo ra từ cùng một spec, nhưng không thể hoán đổi với nhau, mỗi Pod có một định danh bền vững mà nó duy trì qua bất kỳ sự kiện lên lịch lại nào.\nNếu bạn muốn sử dụng các thùng chứa lưu trữ để cung cấp tính bền vững cho công việc của mình, bạn có thể sử dụng StatefulSet như một phần của giải pháp. Mặc dù các Pods riêng lẻ trong một StatefulSet có thể gặp sự cố, các định danh Pod bền vững làm cho việc phù hợp các thùng chứa hiện có với các Pods mới thay thế bất kỳ Pod nào đã thất bại trở nên dễ dàng hơn.\nStatefulSets là có giá trị cho các ứng dụng yêu cầu một hoặc nhiều trong các yếu tố sau:\nCác định danh mạng ổn định, duy nhất Lưu trữ ổn định, bền vững Triển khai và mở rộng dịch vụ một cách đặt hàng, lịch sự Cập nhật cuộn tự động, đặt hàng Trong ứng dụng thương mại điện tử của chúng tôi, chúng tôi đã triển khai một StatefulSet như một phần của dịch vụ nhỏ Catalog. Dịch vụ nhỏ Catalog sử dụng cơ sở dữ liệu MySQL chạy trên EKS. Cơ sở dữ liệu là một ví dụ tốt cho việc sử dụng StatefulSets vì chúng đòi hỏi lưu trữ bền vững. Chúng ta có thể phân tích Pod MySQL Database của chúng ta để xem cấu hình thùng chứa hiện tại của nó:\n$ kubectl describe statefulset -n catalog catalog-mysql Name: catalog-mysql Namespace: catalog [...] Containers: mysql: Image: public.ecr.aws/docker/library/mysql:5.7 Port: 3306/TCP Host Port: 0/TCP Args: --ignore-db-dir=lost+found Environment: MYSQL_ROOT_PASSWORD: my-secret-pw MYSQL_USER: \u0026lt;set to the key \u0026#39;username\u0026#39; in secret \u0026#39;catalog-db\u0026#39;\u0026gt; Optional: false MYSQL_PASSWORD: \u0026lt;set to the key \u0026#39;password\u0026#39; in secret \u0026#39;catalog-db\u0026#39;\u0026gt; Optional: false MYSQL_DATABASE: \u0026lt;set to the key \u0026#39;name\u0026#39; in secret \u0026#39;catalog-db\u0026#39;\u0026gt; Optional: false Mounts: /var/lib/mysql from data (rw) Volumes: data: Type: EmptyDir (a temporary directory that shares a pod\u0026#39;s lifetime) Medium: SizeLimit: \u0026lt;unset\u0026gt; Volume Claims: \u0026lt;none\u0026gt; [...] Như bạn có thể thấy phần Volumes của StatefulSet của chúng ta cho thấy chúng ta chỉ sử dụng một loại thùng chứa EmptyDir mà \u0026ldquo;chia sẻ với tuổi thọ của Pod\u0026rdquo;.\nMột thùng chứa emptyDir được tạo ra khi một Pod được gán cho một nút, và tồn tại trong suốt thời gian mà Pod đó đang chạy trên nút đó. Như tên gọi của nó, thùng chứa emptyDir ban đầu là trống. Tất cả các container trong Pod có thể đọc và ghi các tệp tin trong thùng chứa emptyDir, mặc dù thùng chứa đó có thể được gắn vào các đường dẫn giống nhau hoặc khác nhau trong mỗi container. Khi một Pod được xóa khỏi một nút vì bất kỳ lý do nào, dữ liệu trong emptyDir sẽ bị xóa một cách vĩnh viễn. Do đó, EmptyDir không phù hợp cho cơ sở dữ liệu MySQL của chúng ta.\nChúng ta có thể minh họa điều này bằng cách bắt đầu một phiên shell bên trong container MySQL và tạo một tệp tin thử nghiệm. Sau đó, chúng ta sẽ xóa Pod đang chạy trong StatefulSet của chúng ta. Bởi vì Pod đang sử dụng emptyDir và không phải là Persistent Volume (PV), tệp tin sẽ không tồn tại sau khi Pod được khởi động lại. Đầu tiên, hãy chạy một lệnh bên trong container MySQL của chúng ta để tạo một tệp tin trong đường dẫn emptyDir /var/lib/mysql (nơi MySQL lưu trữ các tệp cơ sở dữ liệu):\n$ kubectl exec catalog-mysql-0 -n catalog -- bash -c \u0026#34;echo 123 \u0026gt; /var/lib/mysql/test.txt\u0026#34; Bây giờ, hãy xác minh rằng tệp test.txt của chúng ta đã được tạo trong thư mục /var/lib/mysql:\n$ kubectl exec catalog-mysql-0 -n catalog -- ls -larth /var/lib/mysql/ | grep -i test -rw-r--r-- 1 root root 4 Oct 18 13:38 test.txt Bây giờ, hãy xóa Pod catalog-mysql hiện tại. Điều này sẽ buộc bộ điều khiển StatefulSet tự động tạo lại một Pod catalog-mysql mới:\n$ kubectl delete pods -n catalog -l app.kubernetes.io/component=mysql pod \u0026#34;catalog-mysql-0\u0026#34; deleted Chờ một vài giây và chạy lệnh dưới đây để kiểm tra xem Pod catalog-mysql đã được tạo lại chưa:\n$ kubectl wait --for=condition=Ready pod -n catalog \\ -l app.kubernetes.io/component=mysql --timeout=30s pod/catalog-mysql-0 condition met $ kubectl get pods -n catalog -l app.kubernetes.io/component=mysql NAME READY STATUS RESTARTS AGE catalog-mysql-0 1/1 Running 0 29s Cuối cùng, hãy thực hiện lại vào shell của container MySQL và chạy một lệnh ls trong đường dẫn /var/lib/mysql để tìm tệp test.txt đã được tạo trước đó:\n$ kubectl exec catalog-mysql-0 -n catalog -- cat /var/lib/mysql/test.txt cat: /var/lib/mysql/test.txt: No such file or directory command terminated with exit code 1 Như bạn có thể thấy, tệp test.txt không còn tồn tại nữa do các thư mục emptyDir là tạm thời. Trong các phần tiếp theo, chúng ta sẽ thực hiện cùng một thử nghiệm và thể hiện cách Persistent Volumes (PVs) sẽ duy trì tệp test.txt và tồn tại qua các lần khởi động lại và/hoặc sự cố của Pod.\nTrên trang tiếp theo, chúng ta sẽ làm việc để hiểu các khái niệm chính về Lưu trữ trên Kubernetes và tích hợp của nó với hệ sinh thái đám mây AWS.\n"
},
{
	"uri": "/vi/4-amazon-efs/4.1/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Trên ứng dụng thương mại điện tử của chúng tôi, chúng tôi đã tạo một deployment như là một phần của dịch vụ microservice của chúng tôi. Dịch vụ microservice sử dụng một máy chủ web chạy trên EKS. Các máy chủ web là một ví dụ tuyệt vời cho việc sử dụng deployments vì chúng mở rộng theo chiều ngang và khai báo trạng thái mới của các Pods.\nThành phần tài sản là một container phục vụ các hình ảnh tĩnh cho sản phẩm, các hình ảnh sản phẩm này được thêm vào như một phần của quá trình xây dựng hình ảnh container. Tuy nhiên, với cài đặt này, mỗi khi nhóm muốn cập nhật hình ảnh sản phẩm, họ phải tạo và triển khai lại hình ảnh container. Trong bài tập này, chúng tôi sẽ sử dụng Hệ thống Tệp EFS và Khối Lưu trữ Vĩnh Viễn Kubernetes để cập nhật hình ảnh sản phẩm cũ và thêm hình ảnh sản phẩm mới mà không cần phải xây dựng lại các hình ảnh container.\nChúng ta có thể bắt đầu bằng cách mô tả Deployment để xem cấu hình khối lượng ban đầu của nó:\n$ kubectl describe deployment -n assets Name: assets Namespace: assets [...] Containers: assets: Image: public.ecr.aws/aws-containers/retail-store-sample-assets:0.4.0 Port: 8080/TCP Host Port: 0/TCP Limits: memory: 128Mi Requests: cpu: 128m memory: 128Mi Liveness: http-get http://:8080/health.html delay=30s timeout=1s period=3s #success=1 #failure=3 Environment Variables from: assets ConfigMap Optional: false Environment: \u0026lt;none\u0026gt; Mounts: /tmp from tmp-volume (rw) Volumes: tmp-volume: Type: EmptyDir (một thư mục tạm thời chia sẻ với tuổi thọ của một Pod) Medium: Memory SizeLimit: \u0026lt;unset\u0026gt; [...] Như bạn có thể thấy phần Volumes của StatefulSet của chúng ta chỉ sử dụng loại khối lượng EmptyDir mà \u0026ldquo;chia sẻ tuổi thọ của Pod\u0026rdquo;.\nMột khối lượng emptyDir được tạo ra khi một Pod được gán cho một nút và tồn tại miễn là Pod đó đang chạy trên nút đó. Như tên gọi, khối lượng emptyDir ban đầu là trống. Tất cả các container trong Pod có thể đọc và ghi các tập tin giống nhau trong khối lượng emptyDir, mặc dù khối lượng đó có thể được gắn vào các đường dẫn giống hoặc khác nhau trong mỗi container. Khi một Pod được loại bỏ khỏi một nút vì bất kỳ lý do nào, dữ liệu trong emptyDir sẽ bị xóa vĩnh viễn. Điều này có nghĩa là nếu chúng ta muốn chia sẻ dữ liệu giữa nhiều Pods trong cùng một Deployment và thực hiện các thay đổi đối với dữ liệu đó, thì EmptyDir không phải là một lựa chọn phù hợp.\nContainer có một số hình ảnh sản phẩm ban đầu được sao chép vào nó như là một phần của quá trình xây dựng hình ảnh container dưới thư mục /usr/share/nginx/html/assets, chúng ta có thể kiểm tra bằng cách chạy lệnh sau:\n$ kubectl exec --stdin deployment/assets \\ -n assets -- bash -c \u0026#34;ls /usr/share/nginx/html/assets/\u0026#34; chrono_classic.jpg gentleman.jpg pocket_watch.jpg smart_1.jpg smart_2.jpg wood_watch.jpg Mở rộng assets Deployment để có nhiều bản sao:\n$ kubectl scale -n assets --replicas=2 deployment/assets $ kubectl rollout status -n assets deployment/assets --timeout=60s Bây giờ hãy thử đặt một hình ảnh sản phẩm mới có tên là newproduct.png trong thư mục /usr/share/nginx/html/assets của Pod đầu tiên bằng lệnh sau:\n$ POD_NAME=$(kubectl -n assets get pods -o jsonpath=\u0026#39;{.items[0].metadata.name}\u0026#39;) $ kubectl exec --stdin $POD_NAME \\ -n assets -- bash -c \u0026#39;touch /usr/share/nginx/html/assets/newproduct.png\u0026#39; Tiếp theo, xác nhận rằng hình ảnh sản phẩm mới newproduct.png không tồn tại trên hệ thống tập tin của Pod thứ hai:\n$ POD_NAME=$(kubectl -n assets get pods -o jsonpath=\u0026#39;{.items[1].metadata.name}\u0026#39;) $ kubectl exec --stdin $POD_NAME \\ -n assets -- bash -c \u0026#39;ls /usr/share/nginx/html/assets\u0026#39; Như bạn thấy, hình ảnh mới được tạo newproduct.png không tồn tại trên Pod thứ hai. Để giải quyết vấn đề này, chúng ta cần một hệ thống tệp có thể được chia sẻ qua nhiều Pod nếu dịch vụ cần mở rộng theo chiều ngang trong khi vẫn thực hiện các cập nhật vào các tệp mà không cần triển khai lại.\n"
},
{
	"uri": "/vi/1-introduce/1.1-docker-storage/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu về Lưu trữ Docker Trong phần này, chúng ta sẽ tìm hiểu về lưu trữ Docker.\nĐể hiểu lưu trữ trong các công cụ điều phối container như Kubernetes, điều quan trọng là hiểu rõ cách lưu trữ hoạt động với các container trước. Hiểu cách lưu trữ hoạt động với Docker trước tiên và làm cho tất cả các khái niệm cơ bản đúng sẽ làm cho việc hiểu cách nó hoạt động trong Kubernetes dễ dàng hơn nhiều sau này.\nNếu bạn mới bắt đầu với Docker thì bạn có thể học một số khái niệm cơ bản của docker từ khóa học Docker cho người mới bắt đầu, miễn phí.\nLưu trữ Docker Có hai khái niệm liên quan đến Docker, đó là các trình điều khiển lưu trữ và các plugin trình điều khiển thư mục. Chúng ta sẽ trước tiên thảo luận về các trình điều khiển lưu trữ. Tài liệu Tham khảo Docker https://docs.docker.com/storage/storagedriver/ https://docs.docker.com/storage/volumes/ "
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Hiểu về mạng trong Kubernetes Hiểu về mạng trong Kubernetes là vô cùng quan trọng để vận hành cụm và ứng dụng của bạn một cách hiệu quả. Trong chương này, chúng ta sẽ đào sâu vào các khía cạnh khác nhau của mạng trong Kubernetes, bao gồm mạng Pod, mạng dịch vụ, và giao tiếp dịch vụ.\nTrong Amazon EKS, mạng Pod, còn được gọi là mạng cụm, được giải quyết thông qua việc sử dụng một plugin CNI của Kubernetes gọi là Amazon VPC CNI. Chúng tôi rất khuyến khích khám phá các tùy chọn khác nhau có sẵn với Amazon VPC CNI trước khi chuyển sang Amazon VPC Lattice.\nCác phần cần tìm hiểu Switching, Routing and Gateways Switching Routing Default Gateway DNS DNS Configuration on Linux CoreDNS Network Namespace Docker Networking CNI Cluster Networking Pod Networking CNI in Kubernetes CoreDNS Ingress "
},
{
	"uri": "/vi/",
	"title": "Kubernetes trên AWS",
	"tags": [],
	"description": "",
	"content": "Kubernetes trên AWS Kubernetes là một nền tảng mã nguồn mở, linh hoạt, có khả năng mở rộng, phục vụ việc quản lý các ứng dụng được đóng gói và các dịch vụ liên quan, giúp việc cấu hình và tự động hóa quá trình triển khai ứng dụng trở nên thuận tiện hơn. Được biết đến như một hệ sinh thái lớn và phát triển nhanh chóng, Kubernetes cung cấp sự hỗ trợ rộng rãi qua các dịch vụ và công cụ đa dạng.\nTên Kubernetes bắt nguồn từ tiếng Hy Lạp, nghĩa là người lái tàu hoặc hoa tiêu. Kubernetes được Google công bố mã nguồn vào năm 2014, dựa trên gần một thập kỷ kinh nghiệm quản lý workload lớn trong thực tế của Google, kết hợp với các ý tưởng và best practices từ cộng đồng.\nQuay ngược thời gian Hãy xem xét tại sao Kubernetes lại quan trọng thông qua việc nhìn lại quá khứ.\nThời kỳ triển khai truyền thống: Ban đầu, các ứng dụng được chạy trực tiếp trên máy chủ vật lý, khiến việc phân bổ tài nguyên gặp khó khăn do không có cơ chế xác định ranh giới tài nguyên cho từng ứng dụng. Cách tiếp cận này dẫn đến nguy cơ một ứng dụng có thể sử dụng quá nhiều tài nguyên, ảnh hưởng đến hoạt động của các ứng dụng khác. Giải pháp là chạy mỗi ứng dụng trên một máy chủ vật lý riêng biệt, nhưng điều này lại không hiệu quả về mặt chi phí và tài nguyên.\nThời kỳ triển khai ảo hóa: Ảo hóa được giới thiệu như một giải pháp cho phép chạy nhiều Máy ảo (VM) trên cùng một máy chủ vật lý, giúp cô lập ứng dụng và tăng cường bảo mật. Ảo hóa cũng giúp cải thiện hiệu quả sử dụng tài nguyên và khả năng mở rộng.\nThời kỳ triển khai Container: Container giống như VM nhưng nhẹ hơn và chia sẻ Hệ điều hành (HĐH) với nhau. Container mang lại nhiều lợi ích như tạo mới và triển khai ứng dụng nhanh chóng, phát triển và triển khai liên tục, phân biệt rõ ràng giữa quá trình phát triển và vận hành, cung cấp tính nhất quán qua các môi trường, khả năng di chuyển giữa các cloud và HĐH, và quản lý ứng dụng tập trung.\nTại sao bạn cần Kubernetes và nó có thể làm gì? Container là phương tiện hiệu quả để đóng gói và chạy ứng dụng của bạn. Trong môi trường sản xuất, cần có cơ chế quản lý các container một cách hiệu quả, đảm bảo không có downtime. Kubernetes giúp quản lý các hệ thống phân tán mạnh mẽ, tự động hóa việc nhân rộng, cung cấp các mẫu triển khai và nhiều hơn nữa.\nKubernetes mang lại:\nPhát hiện dịch vụ và cân bằng tải Điều phối bộ nhớ Tự động rollouts và rollbacks Đóng gói tự động Tự phục hồi Quản lý cấu hình và bảo mật Những gì Kubernetes không phải là Kubernetes không phải là một hệ thống PaaS truyền thống, toàn diện. Nó hoạt động ở tầng container, cung cấp tính năng giống như PaaS như triển khai, nhân rộng, cân bằng tải, nhưng là một giải pháp linh hoạt và có thể mở rộng, không giới hạn loại ứng dụng được hỗ trợ, không triển khai mã nguồn hoặc build ứng dụng, không cung cấp dịch vụ ứng dụng cấp cao như middleware, databases, không bắt buộc sử dụng các giải pháp ghi nhật ký, giám sát hoặc cảnh báo, và không cung cấp hoặc áp dụng bất kỳ cấu hình toàn diện, bảo trì, quản lý hoặc hệ thống tự phục hồi. Kubernetes loại bỏ nhu cầu về điều phối truyền thống, thay vào đó là kiểm soát liên tục từ trạng thái hiện tại sang trạng thái mong muốn.\n"
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Lưu trữ trên EKS Storage on EKS sẽ cung cấp một cái nhìn tổng quan về cách tích hợp hai dịch vụ Lưu trữ của AWS với cụm EKS của bạn.\nTrước khi chúng ta đào sâu vào việc triển khai, dưới đây là một tóm tắt về hai dịch vụ lưu trữ của AWS mà chúng ta sẽ sử dụng và tích hợp với EKS:\nAmazon Elastic Block Store (hỗ trợ EC2): một dịch vụ lưu trữ khối cung cấp truy cập trực tiếp từ các trường hợp EC2 và container đến một ổ lưu trữ được thiết kế cho cả hiệu suất và khối lượng công việc giao dịch ở bất kỳ quy mô nào. Amazon Elastic File System (hỗ trợ Fargate và EC2): một hệ thống tệp được quản lý hoàn toàn, có khả năng mở rộng và đàn hồi phù hợp cho phân tích dữ liệu lớn, phục vụ web và quản lý nội dung, phát triển và kiểm thử ứng dụng, quy trình công việc phương tiện và giải trí, sao lưu cơ sở dữ liệu và lưu trữ container. EFS lưu trữ dữ liệu của bạn một cách dự phòng trên nhiều Khu vực Khả dụng (AZ) và cung cấp truy cập độ trễ thấp từ các pod Kubernetes bất kể AZ chúng đang chạy ở. Amazon FSx for NetApp ONTAP (hỗ trợ EC2): Lưu trữ chia sẻ được quản lý hoàn toàn dựa trên hệ thống tệp ONTAP phổ biến của NetApp. FSx cho NetApp ONTAP lưu trữ dữ liệu của bạn một cách dự phòng trên nhiều Khu vực Khả dụng (AZ) và cung cấp truy cập độ trễ thấp từ các pod Kubernetes bất kể AZ chúng đang chạy ở. FSx for Lustre (hỗ trợ EC2): một hệ thống tệp hoàn toàn được quản lý, hiệu suất cao được tối ưu hóa cho các khối công việc như học máy, tính toán hiệu suất cao, xử lý video, mô hình tài chính, tự động hóa thiết kế điện tử và phân tích. Với FSx cho Lustre, bạn có thể nhanh chóng tạo ra một hệ thống tệp hiệu suất cao liên kết với kho lưu trữ dữ liệu S3 của bạn và truy cập các đối tượng S3 một cách trong suốt như các tệp. FSx sẽ được thảo luận trong các module tương lai của workshop này Quan trọng hơn cả là nắm vững một số khái niệm về Lưu trữ Kubernetes:\nVolumes: Các tệp trên đĩa trong một container là tạm thời, điều này đặt ra một số vấn đề đối với các ứng dụng phức tạp khi chạy trong các container. Một vấn đề là mất các tệp khi một container gặp sự cố. Kubelet khởi động lại container nhưng với một trạng thái sạch sẽ. Một vấn đề thứ hai xảy ra khi chia sẻ tệp giữa các container chạy cùng nhau trong một Pod. Trừu tượng hóa khối lưu trữ Kubernetes giải quyết cả hai vấn đề này. Việc quen thuộc với Pods được đề xuất. Ephemeral Volumes được thiết kế cho các trường hợp sử dụng này. Vì các khối lưu trữ tuân theo vòng đời của Pod và được tạo ra và xóa cùng với Pod, Pods có thể bị dừng lại và khởi động lại mà không bị giới hạn ở nơi mà một số khối lưu trữ lâu dài có sẵn. Persistent Volumes (PV) là một phần của lưu trữ trong một cụm đã được cung cấp bởi một quản trị viên hoặc được cung cấp động bằng cách sử dụng Lớp Lưu trữ. Đó là một tài nguyên trong cụm giống như một nút là một tài nguyên của cụm. PVs là plugin khối lưu trữ giống như Volumes, nhưng có vòng đời độc lập với bất kỳ Pod cụ thể nào sử dụng PV. Đối tượng API này ghi lại các chi tiết của việc triển khai lưu trữ, có thể là NFS, iSCSI hoặc hệ thống lưu trữ cụ thể của nhà cung cấp đám mây. "
},
{
	"uri": "/vi/3-ebs/3.2-ebs-csi-driver/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Trước khi chúng ta đi sâu vào phần này, hãy đảm bảo bạn đã làm quen với các đối tượng lưu trữ Kubernetes (thư mục, thư mục có sức chứa (PV), yêu cầu thư mục có sức chứa (PVC), cấp phát động và lưu trữ tạm thời) được giới thiệu trong phần chính Storage.\nemptyDir là một ví dụ về các thư mục tạm thời, và hiện tại chúng ta đang sử dụng nó trên MySQL StatefulSet, nhưng chúng ta sẽ làm việc để cập nhật nó trong chương này thành Một Thư Mục Có Sức Chứa (PV) sử dụng Cấp Phát Động.\nGiao diện Lưu trữ Container Kubernetes (CSI)](https://kubernetes-csi.github.io/docs/) giúp bạn chạy các ứng dụng chứa trạng thái. Các trình điều khiển CSI cung cấp một giao diện CSI cho phép các cụm Kubernetes quản lý vòng đời của các thư mục có sức chứa. Amazon EKS giúp bạn chạy các khối công việc có trạng thái một cách dễ dàng hơn bằng cách cung cấp các trình điều khiển CSI cho Amazon EBS.\nĐể sử dụng các thư mục Amazon EBS với cấp phát động trên cụm EKS của chúng tôi, chúng ta cần xác nhận rằng chúng ta đã cài đặt Trình điều khiển CSI EBS. Trình điều khiển giao diện lưu trữ Container Elastic Block Store (Amazon EBS) cho phép các cụm dịch vụ Amazon Elastic Kubernetes (Amazon EKS) quản lý vòng đời của các thư mục Amazon EBS cho các thư mục có sức chứa.\nĐể cải thiện bảo mật và giảm lượng công việc, bạn có thể quản lý Trình điều khiển CSI EBS của Amazon như một tiện ích bổ sung cho Amazon EKS. Vai trò IAM cần thiết bởi tiện ích bổ sung đã được tạo cho chúng ta vì vậy chúng ta có thể tiến hành cài đặt tiện ích bổ sung:\n$ aws eks create-addon --cluster-name $EKS_CLUSTER_NAME --addon-name aws-ebs-csi-driver \\ --service-account-role-arn $EBS_CSI_ADDON_ROLE $ aws eks wait addon-active --cluster-name $EKS_CLUSTER_NAME --addon-name aws-ebs-csi-driver Bây giờ chúng ta có thể xem xét những gì đã được tạo ra trong cụm EKS của chúng ta bởi tiện ích bổ sung. Ví dụ, một DaemonSet sẽ chạy một pod trên mỗi nút trong cụm của chúng ta:\n$ kubectl get daemonset ebs-csi-node -n kube-system NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE ebs-csi-node 3 3 3 3 3 kubernetes.io/os=linux 3d21h Chúng ta cũng đã có đối tượng StorageClass được cấu hình sử dụng loại thư mục GP2 của Amazon EBS. Chạy lệnh sau để xác nhận:\n$ kubectl get storageclass NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE gp2 (default) kubernetes.io/aws-ebs Delete WaitForFirstConsumer false 3d22h Bây giờ chúng ta đã hiểu rõ hơn về EKS Storage và các đối tượng Kubernetes. Trên trang kế tiếp, chúng ta sẽ tập trung vào việc sửa đổi MySQL DB StatefulSet của dịch vụ microcatalog để sử dụng một thư mục lưu trữ khối EBS như lưu trữ có sức chứa cho các tập tin cơ sở dữ liệu sử dụng cấp phát động của Kubernetes.\n"
},
{
	"uri": "/vi/4-amazon-efs/4.2/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Trước khi chúng ta đào sâu vào phần này, hãy đảm bảo bạn đã làm quen với các đối tượng lưu trữ Kubernetes (thể hiện bằng các khối lưu trữ, khối lưu trữ vĩnh viễn (PV), yêu cầu khối lưu trữ vĩnh viễn (PVC), cấp phát động và lưu trữ tạm thời) đã được giới thiệu trong Phần Lưu trữ.\nTrình điều khiển Giao diện Lưu trữ Container Amazon Elastic File System (CSI) (https://github.com/kubernetes-sigs/aws-efs-csi-driver) giúp bạn chạy các ứng dụng container có trạng thái. Trình điều khiển Giao diện Lưu trữ Container Amazon Elastic File System (CSI) cung cấp một giao diện CSI cho phép các cụm Kubernetes chạy trên AWS quản lý vòng đời của các hệ thống tệp Amazon EFS.\nĐể tận dụng hệ thống tệp Amazon EFS với cấp phát động trên cụm EKS của chúng tôi, chúng ta cần xác nhận rằng chúng ta đã cài đặt Trình điều khiển CSI EFS. Trình điều khiển Giao diện Lưu trữ Container Amazon Elastic File System (CSI) (https://github.com/kubernetes-sigs/aws-efs-csi-driver) triển khai quy định CSI để các bộ triển khai container quản lý vòng đời của các hệ thống tệp Amazon EFS.\nĐể cải thiện bảo mật và giảm lượng công việc, bạn có thể quản lý trình điều khiển CSI EFS của Amazon như một phần mở rộng của Amazon EKS. Vai trò IAM cần thiết cho phần mở rộng đã được tạo ra cho chúng ta để chúng ta có thể tiến hành cài đặt phần mở rộng:\n$ aws eks create-addon --cluster-name $EKS_CLUSTER_NAME --addon-name aws-efs-csi-driver \\ --service-account-role-arn $EFS_CSI_ADDON_ROLE $ aws eks wait addon-active --cluster-name $EKS_CLUSTER_NAME --addon-name aws-efs-csi-driver Bây giờ chúng ta có thể xem những gì đã được tạo ra trong cụm EKS của chúng ta thông qua phần mở rộng. Ví dụ, một DaemonSet sẽ chạy một pod trên mỗi node trong cụm của chúng ta:\n$ kubectl get daemonset efs-csi-node -n kube-system NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE efs-csi-node 3 3 3 3 3 kubernetes.io/os=linux 47s Trình điều khiển CSI EFS hỗ trợ cấp phát động và tĩnh. Hiện tại, cấp phát động tạo một điểm truy cập cho mỗi PersistentVolume. Điều này có nghĩa là một hệ thống tệp Amazon EFS phải được tạo ra thủ công trên AWS trước và cần được cung cấp như một đầu vào cho tham số StorageClass. Đối với cấp phát tĩnh, hệ thống tệp Amazon EFS cần được tạo ra thủ công trên AWS trước. Sau đó, nó có thể được gắn vào bên trong một container như một khối lưu trữ sử dụng trình điều khiển.\nChúng tôi đã triển khai một hệ thống tệp EFS, các mục tiêu gắn kết và nhóm bảo mật cần thiết đã được triển khai trước với một quy tắc inbound cho phép lưu lượng NFS đến cho các điểm gắn kết Amazon EFS của bạn. Hãy lấy một số thông tin về nó sẽ được sử dụng sau này:\n$ export EFS_ID=$(aws efs describe-file-systems --query \u0026#34;FileSystems[?Name==\u0026#39;$EKS_CLUSTER_NAME-efs-assets\u0026#39;] | [0].FileSystemId\u0026#34; --output text) $ echo $EFS_ID fs-061cb5c5ed841a6b0 Bây giờ, chúng ta sẽ cần tạo một đối tượng StorageClass được cấu hình để sử dụng hệ thống tệp EFS đã triển khai trước như một phần của cơ sở hạ tầng workshop này và sử dụng EFS Access points trong chế độ triển khai.\nChúng ta sẽ sử dụng Kustomize để tạo cho chúng ta lớp lưu trữ và để nhập biến môi trường EFS_ID vào giá trị tham số filesystemid trong cấu hình của đối tượng lớp lưu trữ:\nmanifests/modules/fundamentals/storage/efs/storageclass/efsstorageclass.yaml Hãy áp dụng kustomization này:\n$ kubectl kustomize ~/environment/eks-workshop/modules/fundamentals/storage/efs/storageclass \\ | envsubst | kubectl apply -f- storageclass.storage.k8s.io/efs-sc created Bây giờ chúng ta sẽ lấy và mô tả StorageClass bằng các lệnh dưới đây. Chú ý rằng người cung cấp được sử dụng là trình điều khiển EFS CSI và chế độ triển khai là điểm truy cập EFS và ID của hệ thống tệp như đã xuất trong biến môi trường EFS_ID.\n$ kubectl get storageclass NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE efs-sc efs.csi.aws.com Delete Immediate false 8m29s $ kubectl describe sc efs-sc Name: efs-sc IsDefaultClass: No Annotations: kubectl.kubernetes.io/last-applied-configuration={\u0026#34;apiVersion\u0026#34;:\u0026#34;storage.k8s.io/v1\u0026#34;,\u0026#34;kind\u0026#34;:\u0026#34;StorageClass\u0026#34;,\u0026#34;metadata\u0026#34;:{\u0026#34;annotations\u0026#34;:{},\u0026#34;name\u0026#34;:\u0026#34;efs-sc\u0026#34;},\u0026#34;parameters\u0026#34;:{\u0026#34;directoryPerms\u0026#34;:\u0026#34;700\u0026#34;,\u0026#34;fileSystemId\u0026#34;:\u0026#34;fs-061cb5c5ed841a6b0\u0026#34;,\u0026#34;provisioningMode\u0026#34;:\u0026#34;efs-ap\u0026#34;},\u0026#34;provisioner\u0026#34;:\u0026#34;efs.csi.aws.com\u0026#34;} Provisioner: efs.csi.aws.com Parameters: directoryPerms=700,fileSystemId=fs-061cb5c5ed841a6b0,provisioningMode=efs-ap AllowVolumeExpansion: \u0026lt;unset\u0026gt; MountOptions: \u0026lt;none\u0026gt; ReclaimPolicy: Delete VolumeBindingMode: Immediate Events: \u0026lt;none\u0026gt; Bây giờ chúng ta đã hiểu rõ hơn về StorageClass của EKS và trình điều khiển CSI EFS. Trên trang tiếp theo, chúng tôi sẽ tập trung vào việc sửa đổi dịch vụ microservice tài sản để tận dụng StorageClass EFS bằng cách sử dụng cung cấp dựng dựa trên thể tích động Kubernetes và một PersistentVolume để lưu trữ hình ảnh sản phẩm.\n"
},
{
	"uri": "/vi/1-introduce/1.2-storage/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Lưu trữ trong Docker Trong phần này, chúng ta sẽ xem xét Driver Lưu trữ và Hệ thống tệp của Docker.\nChúng ta sẽ xem xét nơi và cách Docker lưu trữ dữ liệu và cách quản lý hệ thống tệp của các container. Hệ thống tệp Hãy xem cách Docker lưu trữ dữ liệu trên hệ thống tệp cục bộ. Lần đầu tiên, khi bạn cài đặt Docker trên một hệ thống, nó tạo ra cấu trúc thư mục này tại /var/lib/docker.\n$ cd /var/lib/docker/ Bạn có nhiều thư mục con dưới đó gọi là aufs, containers, image, volumes, vv. Đây là nơi mà Docker lưu trữ tất cả dữ liệu của nó theo mặc định. Tất cả các tệp liên quan đến các container được lưu trữ dưới thư mục containers và các tệp liên quan đến các hình ảnh được lưu trữ dưới thư mục image. Bất kỳ thư mục nào được tạo bởi các container Docker đều được tạo dưới thư mục volumes. Bây giờ, hãy chỉ hiểu nơi Docker lưu trữ các tệp của hình ảnh và một container và định dạng nào. Để hiểu điều đó, chúng ta cần hiểu về kiến ​​trúc lớp của Docker. Kiến ​​trúc lớp Khi Docker xây dựng hình ảnh, nó xây dựng chúng trong một kiến ​​trúc lớp. Mỗi dòng lệnh trong tệp Docker tạo một lớp mới trong hình ảnh Docker chỉ với các thay đổi từ lớp trước đó. Như bạn có thể thấy trong hình ảnh, lớp-1 là lớp cơ sở Ubuntu, lớp-2 cài đặt các gói, lớp-3 cài đặt các gói Python, lớp-4 cập nhật mã nguồn, lớp-5 cập nhật điểm vào của hình ảnh. Khi mỗi lớp chỉ lưu trữ các thay đổi từ lớp trước đó. Nó cũng được phản ánh trong kích thước. Để hiểu rõ hơn về các ưu điểm của kiến ​​trúc lớp này, hãy xem một Dockerfile khác, điều này rất giống với ứng dụng đầu tiên của chúng tôi. chỉ mã nguồn và điểm vào là khác nhau để tạo ra ứng dụng này. Khi hình ảnh được xây dựng, Docker sẽ không xây dựng ba lớp đầu tiên mà thay vào đó sẽ sử dụng lại ba lớp giống như các lớp đã xây dựng cho ứng dụng đầu tiên từ bộ nhớ cache. Chỉ tạo ra hai lớp cuối cùng với nguồn và điểm vào mới. Như vậy, Docker xây dựng hình ảnh nhanh chóng và hiệu quả tiết kiệm không gian đĩa. Điều này cũng áp dụng nếu bạn muốn cập nhật mã ứng dụng của mình. Docker đơn giản là sử dụng lại tất cả các lớp trước đó từ bộ nhớ cache và nhanh chóng xây dựng lại hình ảnh ứng dụng bằng cách cập nhật mã nguồn mới nhất. Hãy sắp xếp lại các lớp từ dưới lên để chúng ta có thể hiểu rõ hơn. Tất cả các lớp này được tạo ra khi chúng ta chạy lệnh Docker build để hình thành hình ảnh Docker cuối cùng. Khi quá trình xây dựng hoàn tất, bạn không thể chỉnh sửa nội dung của các lớp này và vì vậy chúng là chỉ đọc và bạn chỉ có thể chỉnh sửa chúng bằng cách khởi tạo một quá trình xây dựng mới. Khi bạn chạy một container dựa trên hình ảnh này, bằng cách sử dụng lệnh Docker run Docker tạo ra một container dựa trên các lớp này và tạo ra một lớp có thể ghi mới trên lớp hình ảnh. Lớp có thể ghi được sử dụng để lưu trữ dữ liệu được tạo ra bởi container như các tệp nhật ký được viết bởi các ứng dụng, bất kỳ tệp tạm thời nào được tạo ra bởi container. Khi container bị hủy, lớp này và tất cả các thay đổi được lưu trữ trong đó cũng bị hủy. Hãy nhớ rằng cùng một lớp hình ảnh được chia sẻ bởi tất c "
},
{
	"uri": "/vi/3-ebs/3.3-statefulset-with-ebs-volume/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Cập nhật MySQL DB cho dịch vụ Catalog sử dụng EBS Volume Bây giờ khi chúng ta đã hiểu về StatefulSets và Dynamic Volume Provisioning, hãy thay đổi MySQL DB trên dịch vụ Catalog để cung cấp một EBS volume mới để lưu trữ các tập tin cơ sở dữ liệu một cách liên tục.\nSử dụng Kustomize, chúng ta sẽ thực hiện hai việc:\nTạo một StatefulSet mới cho cơ sở dữ liệu MySQL được sử dụng bởi thành phần catalog sử dụng một EBS volume. Cập nhật thành phần catalog để sử dụng phiên bản cơ sở dữ liệu mới này. :::info Tại sao chúng ta không cập nhật StatefulSet hiện có? Các trường chúng ta cần cập nhật là bất biến và không thể thay đổi. :::\nỞ đây trong StatefulSet cơ sở dữ liệu catalog mới:\nmanifests/modules/fundamentals/storage/ebs/statefulset-mysql.yaml Chú ý đến trường volumeClaimTemplates mô tả hướng dẫn cho Kubernetes sử dụng Dynamic Volume Provisioning để tạo một EBS Volume mới, một PersistentVolume (PV) và một PersistentVolumeClaim (PVC) tất cả đều tự động.\nĐây là cách chúng ta sẽ cấu hình lại thành phần catalog để sử dụng StatefulSet mới:\nmodules/fundamentals/storage/ebs/deployment.yaml\rDeployment/catalog Áp dụng các thay đổi và chờ đợi các Pod mới được triển khai:\n$ kubectl apply -k ~/environment/eks-workshop/modules/fundamentals/storage/ebs/ $ kubectl rollout status --timeout=100s statefulset/catalog-mysql-ebs -n catalog Bây giờ hãy xác nhận rằng StatefulSet mới triển khai của chúng ta đang chạy:\n$ kubectl get statefulset -n catalog catalog-mysql-ebs NAME READY AGE catalog-mysql-ebs 1/1 79s Kiểm tra StatefulSet catalog-mysql-ebs của chúng ta, chúng ta có thể thấy rằng bây giờ chúng ta có một PersistentVolumeClaim được đính kèm với dung lượng 30GiB và với storageClassName là gp2.\n$ kubectl get statefulset -n catalog catalog-mysql-ebs \\ -o jsonpath=\u0026#39;{.spec.volumeClaimTemplates}\u0026#39; | jq . [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;PersistentVolumeClaim\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;creationTimestamp\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34; }, \u0026#34;spec\u0026#34;: { \u0026#34;accessModes\u0026#34;: [ \u0026#34;ReadWriteOnce\u0026#34; ], \u0026#34;resources\u0026#34;: { \u0026#34;requests\u0026#34;: { \u0026#34;storage\u0026#34;: \u0026#34;30Gi\u0026#34; } }, \u0026#34;storageClassName\u0026#34;: \u0026#34;gp2\u0026#34;, \u0026#34;volumeMode\u0026#34;: \u0026#34;Filesystem\u0026#34; }, \u0026#34;status\u0026#34;: { \u0026#34;phase\u0026#34;: \u0026#34;Pending\u0026#34; } } ] Chúng ta có thể phân tích cách Dynamic Volume Provisioning tạo một PersistentVolume (PV) tự động cho chúng ta:\n$ kubectl get pv | grep -i catalog pvc-1df77afa-10c8-4296-aa3e-cf2aabd93365 30Gi RWO Delete Bound catalog/data-catalog-mysql-ebs-0 gp2 10m Sử dụng AWS CLI, chúng ta có thể kiểm tra volume Amazon EBS đã được tạo tự động cho chúng ta:\n$ aws ec2 describe-volumes \\ --filters Name=tag:kubernetes.io/created-for/pvc/name,Values=data-catalog-mysql-ebs-0 \\ --query \u0026#34;Volumes[*].{ID:VolumeId,Tag:Tags}\u0026#34; \\ --no-cli-pager Nếu bạn muốn, bạn cũng có thể kiểm tra nó qua bảng điều khiển AWS, chỉ cần tìm kiếm các EBS volumes với tag có key kubernetes.io/created-for/pvc/name và giá trị là data-catalog-mysql-ebs-0:\nNếu bạn muốn kiểm tra shell của container và kiểm tra ổ đĩa EBS mới được gắn vào hệ điều hành Linux, hãy chạy lệnh này để thực thi một lệnh shell vào container catalog-mysql-ebs. Nó sẽ kiểm tra các hệ thống tập tin mà bạn đã gắn kết:\n$ kubectl exec --stdin catalog-mysql-ebs-0 -n catalog -- bash -c \u0026#34;df -h\u0026#34; Filesystem Size Used Avail Use% Mounted on overlay 100G 7.6G 93G 8% / tmpfs 64M 0 64M 0% /dev tmpfs 3.8G 0 3.8G 0% /sys/fs/cgroup /dev/nvme0n1p1 100G 7.6G 93G 8% /etc/hosts shm 64M 0 64M 0% /dev/shm /dev/nvme1n1 30G 211M 30G 1% /var/lib/mysql tmpfs 7.0G 12K 7.0G 1% /run/secrets/kubernetes.io/serviceaccount tmpfs 3.8G 0 3.8G 0% /proc/acpi tmpfs 3.8G 0 3.8G 0% /sys/firmware Kiểm tra ổ đĩa hiện đang được gắn vào /var/lib/mysql. Đây là Ổ đĩa EBS cho các tập tin cơ sở dữ liệu MySQL có trạng thái được lưu trữ theo cách liên tục.\nBây giờ, hãy thử nghiệm xem dữ liệu của chúng ta có thực sự liên tục hay không. Chúng ta sẽ tạo tệp test.txt giống hệt như chúng ta đã làm trong phần đầu tiên của module này:\n$ kubectl exec catalog-mysql-ebs-0 -n catalog -- bash -c \u0026#34;echo 123 \u0026gt; /var/lib/mysql/test.txt\u0026#34; Bây giờ, hãy xác minh rằng tệp test.txt của chúng ta đã được tạo trong thư mục /var/lib/mysql:\n$ kubectl exec catalog-mysql-ebs-0 -n catalog -- ls -larth /var/lib/mysql/ | grep -i test -rw-r--r-- 1 root root 4 Oct 18 13:57 test.txt Bây giờ, hãy xóa Pod hiện tại catalog-mysql-ebs, điều này sẽ buộc bộ điều khiển StatefulSet tự động tạo lại nó:\n$ kubectl delete pods -n catalog catalog-mysql-ebs-0 pod \u0026#34;catalog-mysql-ebs-0\u0026#34; deleted Đợi vài giây, và chạy lệnh dưới đây để kiểm tra xem Pod catalog-mysql-ebs đã được tạo lại chưa:\n$ kubectl wait --for=condition=Ready pod -n catalog \\ -l app.kubernetes.io/component=mysql-ebs --timeout=60s pod/catalog-mysql-ebs-0 condition met $ kubectl get pods -n catalog -l app.kubernetes.io/component=mysql-ebs NAME READY STATUS RESTARTS AGE catalog-mysql-ebs-0 1/1 Running 0 29s Cuối cùng, hãy thực thi trở lại vào shell container MySQL và chạy lệnh ls trên đường dẫn /var/lib/mysql để tìm kiếm tệp test.txt mà chúng ta đã tạo, và xem liệu tệp đã được lưu liên tục hay không:\n$ kubectl exec catalog-mysql-ebs-0 -n catalog -- ls -larth /var/lib/mysql/ | grep -i test -rw-r--r-- 1 mysql root 4 Oct 18 13:57 test.txt $ kubectl exec catalog-mysql-ebs-0 -n catalog -- cat /var/lib/mysql/test.txt 123 Như bạn có thể thấy, tệp test.txt vẫn có sẵn sau khi xóa và khởi động lại Pod và với nội dung đúng trên đó là 123. Đây là chức năng chính của Khối lưu trữ liên tục (PVs). Amazon EBS đang lưu trữ dữ liệu và giữ dữ liệu của chúng ta an toàn và có sẵn trong một khu vực khả dụng của AWS.\n"
},
{
	"uri": "/vi/3-ebs/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị môi trường cho phần này: $ prepare-environment fundamentals/storage/ebs Điều này sẽ thực hiện các thay đổi sau vào môi trường thí nghiệm của bạn:\nTạo vai trò IAM cần thiết cho tiện ích điều khiển CSI của EBS. Bạn có thể xem Terraform áp dụng các thay đổi này tại đây.\nAmazon Elastic Block Store là dịch vụ lưu trữ khối dễ sử dụng, có khả năng mở rộng và hiệu suất cao. Nó cung cấp khối lưu trữ có tính liên tục (không bay hơi) cho người dùng. Lưu trữ liên tục cho phép người dùng lưu trữ dữ liệu của họ cho đến khi họ quyết định xóa dữ liệu.\nTrong phần thực hành này, chúng ta sẽ tìm hiểu về các khái niệm sau:\nKubernetes StatefulSets Trình điều khiển CSI của EBS StatefulSet với Ổ đĩa EBS "
},
{
	"uri": "/vi/4-amazon-efs/4.3/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Bây giờ khi chúng ta đã hiểu về lớp lưu trữ EFS cho Kubernetes, hãy tạo một Persistent Volume và thay đổi container assets trên deployment assets để mount Volume được tạo.\nĐầu tiên, hãy kiểm tra tệp efspvclaim.yaml để xem các tham số trong tệp và yêu cầu về kích thước lưu trữ cụ thể là 5GB từ lớp lưu trữ efs-sc mà chúng ta đã tạo trong bước trước:\nmanifests/modules/fundamentals/storage/efs/deployment/efspvclaim.yaml Chúng ta cũng sẽ sửa đổi dịch vụ assets theo hai cách:\nMount PVC vào vị trí nơi các hình ảnh assets được lưu trữ Thêm một init container để sao chép các hình ảnh ban đầu vào thư mục EFS modules/fundamentals/storage/efs/deployment/deployment.yaml\rDeployment/assets Chúng ta có thể áp dụng các thay đổi bằng cách chạy lệnh sau:\n$ kubectl apply -k ~/environment/eks-workshop/modules/fundamentals/storage/efs/deployment namespace/assets không thay đổi serviceaccount/assets không thay đổi configmap/assets không thay đổi service/assets không thay đổi persistentvolumeclaim/efs-claim được tạo deployment.apps/assets được cấu hình $ kubectl rollout status --timeout=130s deployment/assets -n assets Bây giờ hãy nhìn vào volumeMounts trong deployment, chú ý rằng chúng ta có Volume mới của mình được đặt tên là efsvolume được mount trên volumeMounts với tên /usr/share/nginx/html/assets:\n$ kubectl get deployment -n assets \\ -o yaml | yq \u0026#39;.items[].spec.template.spec.containers[].volumeMounts\u0026#39; - mountPath: /usr/share/nginx/html/assets name: efsvolume - mountPath: /tmp name: tmp-volume Tạo Một PersistentVolume (PV) Tự Động cho PersistentVolumeClaim (PVC) Trong bước trước đó, chúng ta đã tạo một PersistentVolumeClaim (PVC), và một PersistentVolume (PV) đã được tạo tự động cho nó:\n$ kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pvc-342a674d-b426-4214-b8b6-7847975ae121 5Gi RWX Delete Bound assets/efs-claim efs-sc 2m33s Mô tả thêm về PersistentVolumeClaim (PVC) được tạo:\n$ kubectl describe pvc -n assets Name: efs-claim Namespace: assets StorageClass: efs-sc Status: Bound Volume: pvc-342a674d-b426-4214-b8b6-7847975ae121 Labels: \u0026lt;none\u0026gt; Annotations: pv.kubernetes.io/bind-completed: yes pv.kubernetes.io/bound-by-controller: yes volume.beta.kubernetes.io/storage-provisioner: efs.csi.aws.com volume.kubernetes.io/storage-provisioner: efs.csi.aws.com Finalizers: [kubernetes.io/pvc-protection] Capacity: 5Gi Access Modes: RWX VolumeMode: Filesystem Used By: \u0026lt;none\u0026gt; Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ExternalProvisioning 34s persistentvolume-controller waiting for a volume to be created, either by external provisioner \u0026#34;efs.csi.aws.com\u0026#34; or manually created by system administrator Normal Provisioning 34s efs.csi.aws.com_efs-csi-controller-6b4ff45b65-fzqjb_7efe91cc-099a-45c7-8419-6f4b0a4f9e01 External provisioner is provisioning volume for claim \u0026#34;assets/efs-claim\u0026#34; Normal ProvisioningSucceeded 33s efs.csi.aws.com_efs-csi-controller-6b4ff45b65-fzqjb_7efe91cc-099a-45c7-8419-6f4b0a4f9e01 Successfully provisioned volume pvc-342a674d-b426-4214-b8b6-7847975ae121 Tạo Một File Mới newproduct.png Trong Thư Mục Assets của Pod Đầu Tiên $ POD_NAME=$(kubectl -n assets get pods -o jsonpath=\u0026#39;{.items[0].metadata.name}\u0026#39;) $ kubectl exec --stdin $POD_NAME \\ -n assets -c assets -- bash -c \u0026#39;touch /usr/share/nginx/html/assets/newproduct.png\u0026#39; Sau đó, xác nhận rằng tập tin cũng tồn tại trong Pod thứ hai:\n$ POD_NAME=$(kubectl -n assets get pods -o jsonpath=\u0026#39;{.items[1].metadata.name}\u0026#39;) $ kubectl exec --stdin $POD_NAME \\ -n assets -c assets -- bash -c \u0026#39;ls /usr/share/nginx/html/assets\u0026#39; chrono_classic.jpg gentleman.jpg newproduct.png \u0026lt;----------- pocket_watch.jpg smart_1.jpg smart_2.jpg test.txt wood_watch.jpg Như bạn có thể thấy, ngay cả khi chúng ta tạo một tập tin thông qua Pod đầu tiên, Pod thứ hai cũng có quyền truy cập vào tập tin này nhờ vào hệ thống tệp EFS được chia sẻ.\n"
},
{
	"uri": "/vi/1-introduce/1.3-volume-driver-plugins-in-docker/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Plugin Volume Driver trong Docker Điều hướng tới Bài giảng Trong phần này, chúng ta sẽ tìm hiểu về Plugin Volume Driver trong Docker\nChúng ta đã thảo luận về các driver lưu trữ. Các driver lưu trữ giúp quản lý lưu trữ trên hình ảnh và container. Chúng ta đã biết rằng nếu bạn muốn lưu trữ lâu dài, bạn phải tạo ra các thùng chứa. Các thùng chứa không được quản lý bởi các driver lưu trữ. Các thùng chứa được quản lý bởi các plugin driver thùng chứa. Plugin driver thùng chứa mặc định là local. Plugin thùng chứa local giúp tạo ra một thùng chứa trên máy chủ Docker và lưu trữ dữ liệu của nó dưới thư mục /var/lib/docker/volumes/. Có nhiều plugin driver thùng chứa khác cho phép bạn tạo ra một thùng chứa trên các giải pháp của bên thứ ba như lưu trữ tệp Azure, Lưu trữ khối DigitalOcean, Portworx, Đĩa cố định Google Compute, v.v. Khi bạn chạy một container Docker, bạn có thể chọn sử dụng một plugin driver thùng chứa cụ thể, như RexRay EBS để cung cấp một thùng chứa từ Amazon EBS. Điều này sẽ tạo ra một container và gắn kết một thùng chứa từ điện toán đám mây AWS. Khi container kết thúc, dữ liệu của bạn được an toàn trên điện toán đám mây. $ docker run -it --name mysql --volume-driver rexray/ebs --mount src=ebs-vol,target=/var/lib/mysql mysql Tài liệu tham khảo Docker https://docs.docker.com/engine/extend/legacy_plugins/ https://github.com/rexray/rexray "
},
{
	"uri": "/vi/4-amazon-efs/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị môi trường cho phần này: $ prepare-environment fundamentals/storage/efs Điều này sẽ thực hiện các thay đổi sau vào môi trường thí nghiệm của bạn:\nTạo một vai trò IAM cho trình điều khiển CSI của Amazon EFS Tạo một hệ thống tập tin Amazon EFS Bạn có thể xem Terraform áp dụng các thay đổi này tại đây.\nAmazon Elastic File System là một hệ thống tập tin linh hoạt, không cần máy chủ, đơn giản và tự động quên dành cho việc sử dụng với dịch vụ Đám mây AWS và các tài nguyên trên cơ sở. Nó được xây dựng để tự động mở rộng theo yêu cầu đến petabyte mà không làm gián đoạn các ứng dụng, tự động mở rộng và thu nhỏ khi bạn thêm và loại bỏ các tệp, loại bỏ nhu cầu về việc cấp và quản lý dung lượng để chứa sự tăng trưởng.\nTrong bài thực hành này, chúng ta sẽ tìm hiểu về các khái niệm sau:\nTriển khai dịch vụ microservices tài sản Trình điều khiển CSI của EFS Cung cấp động bằng cách sử dụng EFS và một triển khai Kubernetes "
},
{
	"uri": "/vi/1-introduce/1.4-container-storage-interface/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giao diện Lưu trữ Container Trong phần này, chúng ta sẽ tìm hiểu về Giao diện Lưu trữ Container.\nGiao diện Thực thi Container Kubernetes sử dụng Docker một mình làm động cơ thực thi container, và toàn bộ mã để làm việc với Docker được nhúng trong mã nguồn Kubernetes. Các động cơ thực thi container khác, như rkt và CRI-O. Giao diện Thực thi Container là một tiêu chuẩn xác định cách một giải pháp điều phối như Kubernetes sẽ giao tiếp với các động cơ thực thi container như Docker. Nếu bất kỳ giao diện thực thi container mới nào được phát triển, họ có thể đơn giản là tuân thủ các tiêu chuẩn CRI. Giao diện Mạng Container Để hỗ trợ các giải pháp mạng khác nhau, giao diện mạng container được giới thiệu. Bất kỳ nhà cung cấp mạng lưới mới nào cũng có thể đơn giản phát triển plugin của họ dựa trên các tiêu chuẩn CNI và làm cho giải pháp của họ hoạt động với Kubernetes. Giao diện Lưu trữ Container Giao diện lưu trữ container được phát triển để hỗ trợ nhiều giải pháp lưu trữ. Với CSI, bạn hiện có thể viết các trình điều khiển của riêng mình cho lưu trữ của riêng bạn để hoạt động với Kubernetes. Portworx, Amazon EBS, Ảo Disk Azure, GlusterFS vv. CSI không phải là một tiêu chuẩn cụ thể của Kubernetes. Nó được thiết kế để là một tiêu chuẩn phổ quát và nếu triển khai, cho phép bất kỳ công cụ điều phối container nào làm việc với bất kỳ nhà cung cấp lưu trữ nào có plugin được hỗ trợ. Kubernetes, Cloud Foundry và Mesos đều tham gia với CSI. Nó xác định một tập hợp các RPC hoặc cuộc gọi thủ tục từ xa sẽ được gọi bởi trình điều phối container. Các trình điều khiển lưu trữ phải triển khai các RPC này. Giao diện Lưu trữ Container https://github.com/container-storage-interface/spec https://kubernetes-csi.github.io/docs/ http://mesos.apache.org/documentation/latest/csi/ https://www.nomadproject.io/docs/internals/plugins/csi#volume-lifecycle "
},
{
	"uri": "/vi/1-introduce/1.5-volumes/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tích Hợp Ổ Đĩa (Volumes) Trong phần này, chúng ta sẽ xem xét về Tích Hợp Ổ Đĩa (Volumes)\nChúng ta đã thảo luận về lưu trữ Docker, Nếu chúng ta không gắn kết ổ đĩa vào thời gian chạy container, khi container bị hủy và sau đó tất cả dữ liệu sẽ bị mất. Vì vậy, chúng ta cần lưu trữ dữ liệu vào bên trong container Docker để đính kèm một ổ đĩa cho các container khi chúng được tạo ra.\nDữ liệu được xử lý bởi container hiện đang được đặt trong ổ đĩa này, giữ nó vĩnh viễn. Ngay cả khi container bị xóa, dữ liệu vẫn tồn tại trong ổ đĩa.\nTrong thế giới Kubernetes, các POD được tạo ra trong Kubernetes có tính chất tạm thời. Khi một POD được tạo ra để xử lý dữ liệu và sau đó bị xóa, dữ liệu được xử lý bởi nó cũng bị xóa đi.\nVí dụ, chúng ta tạo ra một POD đơn giản tạo ra một số ngẫu nhiên từ 1 đến 100 và ghi nó vào một tệp tại /opt/number.out. Để lưu trữ vào ổ đĩa.\nChúng ta tạo ra một ổ đĩa cho điều đó. Trong trường hợp này, tôi chỉ định một đường dẫn /data trên máy chủ. Các tệp được lưu trữ trong thư mục data trên nút của tôi. Chúng ta sử dụng trường volumeMounts trong mỗi container để gắn ổ đĩa dữ liệu vào thư mục /opt bên trong container. Số ngẫu nhiên sẽ được ghi vào /opt mount bên trong container, đó cũng là ổ đĩa dữ liệu nằm trong thư mục /data trên máy chủ thực tế. Khi POD bị xóa, tệp chứa số ngẫu nhiên vẫn còn tồn tại trên máy chủ.\nCác Lựa Chọn Lưu Trữ Ổ Đĩa Trong các ổ đĩa, loại ổ đĩa hostPath là tốt cho một nút duy nhất. Nó không được khuyến nghị sử dụng trong các cụm nhiều nút. Trong Kubernetes, nó hỗ trợ một số loại giải pháp lưu trữ tiêu chuẩn như NFS, GlusterFS, CephFS hoặc các giải pháp đám mây công cộng như AWS EBS, Azure Disk hoặc Google\u0026rsquo;s Persistent Disk. volumes:\r- name: data-volume\rawsElasticBlockStore:\rvolumeID: \u0026lt;volume-id\u0026gt;\rfsType: ext4 Tài Liệu Tham Khảo Ổ Đĩa Kubernetes https://kubernetes.io/docs/concepts/storage/volumes/ https://kubernetes.io/docs/tasks/configure-pod-container/configure-volume-storage/ https://unofficial-kubernetes.readthedocs.io/en/latest/concepts/storage/volumes/ https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#volume-v1-core "
},
{
	"uri": "/vi/1-introduce/1.6-persistent-volumes/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Khối Lưu Trữ Cố Định Điều hướng đến Bài Giảng Trong phần này, chúng ta sẽ xem xét về Khối Lưu Trữ Cố Định\nTrong môi trường lớn, với nhiều người dùng triển khai nhiều pods, người dùng sẽ phải cấu hình lưu trữ mỗi lần cho mỗi Pod. Bất kể giải pháp lưu trữ nào được sử dụng, người dùng triển khai các pods sẽ phải cấu hình chúng trên tất cả các tệp định nghĩa pods trong môi trường của mình. Mỗi khi có thay đổi, người dùng sẽ phải thực hiện chúng trên tất cả các pods của mình. Một Khối Lưu Trữ Cố Định là một cụm lưu trữ trên toàn cụm được cấu hình bởi một quản trị viên để được sử dụng bởi người dùng triển khai ứng dụng trên cụm. Người dùng có thể lựa chọn lưu trữ từ cụm này bằng cách sử dụng các Yêu Cầu Khối Lưu Trữ Cố Định.\npv-definition.yaml kind: PersistentVolume apiVersion: v1 metadata: name: pv-vol1 spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] capacity: storage: 1Gi hostPath: path: /tmp/data $ kubectl create -f pv-definition.yaml persistentvolume/pv-vol1 created $ kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pv-vol1 1Gi RWO Retain Available 3min $ kubectl delete pv pv-vol1 persistentvolume \u0026#34;pv-vol1\u0026#34; deleted Khối Lưu Trữ Cố Định Kubernetes https://kubernetes.io/docs/concepts/storage/persistent-volumes/ https://portworx.com/tutorial-kubernetes-persistent-volumes/ "
},
{
	"uri": "/vi/1-introduce/1.7-persistent-volume-claims/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Yêu cầu Khối Lưu Trữ Đưa tôi đến Bài giảng Trong phần này, chúng ta sẽ xem xét Yêu cầu Khối Lưu Trữ\nBây giờ chúng ta sẽ tạo một Yêu cầu Khối Lưu Trữ để làm cho lưu trữ có sẵn cho node. Khối Lưu Trữ và Yêu cầu Khối Lưu Trữ là hai đối tượng riêng biệt trong không gian tên Kubernetes. Khi Yêu cầu Khối Lưu Trữ được tạo, Kubernetes sẽ gán các Khối Lưu Trữ vào yêu cầu dựa trên yêu cầu và thuộc tính được thiết lập trên khối. Nếu các thuộc tính không khớp hoặc Khối Lưu Trữ không có sẵn cho Yêu cầu Khối Lưu Trữ thì nó sẽ hiển thị trạng thái đang chờ. pvc-definition.yaml kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi pv-definition.yaml kind: PersistentVolume apiVersion: v1 metadata: name: pv-vol1 spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] capacity: storage: 1Gi hostPath: path: /tmp/data Tạo Khối Lưu Trữ $ kubectl create -f pv-definition.yaml\rpersistentvolume/pv-vol1 đã được tạo\r$ kubectl get pv\rNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE\rpv-vol1 1Gi RWO Retain Available 10s Tạo Yêu Cầu Khối Lưu Trữ $ kubectl create -f pvc-definition.yaml\rpersistentvolumeclaim/myclaim đã được tạo\r$ kubectl get pvc\rNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyclaim Pending 35s\r$ kubectl get pvc\rNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\rmyclaim Bound pv-vol1 1Gi RWO 1min Xóa Yêu Cầu Khối Lưu Trữ $ kubectl delete pvc myclaim Xóa Khối Lưu Trữ $ kubectl delete pv pv-vol1 Tài liệu Tham Khảo về Yêu Cầu Khối Lưu Trữ Kubernetes https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#persistentvolumeclaim-v1-core https://docs.cloud.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengcreatingpersistentvolumeclaim.htm "
},
{
	"uri": "/vi/1-introduce/1.8-using-pvc-in-pods/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Sử dụng PVC trong PODs Đi đến Bài giảng Trong phần này, chúng ta sẽ tìm hiểu về Sử dụng PVC trong PODs\nTrong trường hợp này, PODs truy cập vào bộ nhớ lưu trữ bằng cách sử dụng yêu cầu làm một khối. Persistent Volume Claim phải tồn tại trong cùng namespace với Pod sử dụng yêu cầu. Cụm sẽ tìm thấy yêu cầu trong namespace của Pod và sử dụng nó để lấy Persistent Volume hậu bổng yêu cầu. Khối sau đó được gắn vào máy chủ và vào Pod. Persistent Volume là phạm vi của cụm và Persistent Volume Claim là phạm vi của namespace. Tạo Persistent Volume pv-definition.yaml kind: PersistentVolume apiVersion: v1 metadata: name: pv-vol1 spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] capacity: storage: 1Gi hostPath: path: /tmp/data $ kubectl create -f pv-definition.yaml Tạo Persistent Volume Claim pvc-definition.yaml kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi $ kubectl create -f pvc-definition.yaml Tạo một Pod pod-definition.yaml apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: myfrontend image: nginx volumeMounts: - mountPath: \u0026#34;/var/www/html\u0026#34; name: web volumes: - name: web persistentVolumeClaim: claimName: myclaim $ kubectl create -f pod-definition.yaml Liệt kê các Pod, Persistent Volume và Persistent Volume Claim $ kubectl get pod,pvc,pv Tài liệu tham khảo https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes "
},
{
	"uri": "/vi/1-introduce/1.9-storage-class/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Lớp Lưu Trữ Trong phần này, chúng ta sẽ xem xét về Lớp Lưu Trữ\nChúng ta đã thảo luận về cách tạo Volume Bền Vững và Yêu Cầu Volume Bền Vững và Chúng ta cũng đã thấy cách sử dụng vào không gian Volume của Pod để yêu cầu không gian volume đó. Chúng ta đã tạo Volume Bền Vững nhưng trước khi điều này nếu chúng ta đang lấy một volume từ các nhà cung cấp Đám Mây như GCP, AWS, Azure. Chúng ta cần phải tạo ổ đĩa trong Google Cloud là một ví dụ. Chúng ta cần phải tạo thủ công mỗi khi khi chúng ta định nghĩa trong tệp định nghĩa Pod. Điều này được gọi là Cung Cấp Tĩnh. Cung Cấp Tĩnh Cung Cấp Động Bây giờ chúng ta có một Lớp Lưu Trữ, Vì vậy chúng ta không cần phải định nghĩa Volume Bền Vững nữa. Nó sẽ được tạo tự động khi một Lớp Lưu Trữ được tạo. Điều này được gọi là Cung Cấp Động. sc-definition.yaml\rapiVersion: storage.k8s.io/v1\rkind: StorageClass\rmetadata:\rname: google-storage\rprovisioner: kubernetes.io/gce-pd Tạo Một Lớp Lưu Trữ $ kubectl create -f sc-definition.yaml\rstorageclass.storage.k8s.io/google-storage created Liệt Kê Các Lớp Lưu Trữ $ kubectl get sc\rNAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE\rgoogle-storage kubernetes.io/gce-pd Delete Immediate false 20s Tạo Yêu Cầu Volume Bền Vững pvc-definition.yaml\rkind: PersistentVolumeClaim\rapiVersion: v1\rmetadata:\rname: myclaim\rspec:\raccessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ]\rstorageClassName: google-storage resources:\rrequests:\rstorage: 500Mi $ kubectl create -f pvc-definition.yaml Tạo Một Pod pod-definition.yaml\rapiVersion: v1\rkind: Pod\rmetadata:\rname: mypod\rspec:\rcontainers:\r- name: frontend\rimage: nginx\rvolumeMounts:\r- mountPath: \u0026#34;/var/www/html\u0026#34;\rname: web\rvolumes:\r- name: web\rpersistentVolumeClaim:\rclaimName: myclaim $ kubectl create -f pod-definition.yaml Người Cung Cấp Tài liệu Tham Khảo Lớp Lưu Trữ Kubernetes https://kubernetes.io/docs/concepts/storage/storage-classes/ https://cloud.google.com/kubernetes-engine/docs/concepts/persistent-volumes#storageclasses https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]