[
{
	"uri": "//localhost:1313/vi/8-policy-management-with-kyverno/8.1-creating-a-simple-policy/",
	"title": "Creating a Simple Policy",
	"tags": [],
	"description": "",
	"content": "Để hiểu về Chính sách Kyverno, chúng ta sẽ bắt đầu bài thực hành của mình với một yêu cầu nhãn Pod đơn giản. Như bạn có thể biết, Nhãn trong Kubernetes có thể được sử dụng để gắn thẻ các đối tượng và tài nguyên trong Cụm.\nDưới đây là một chính sách mẫu yêu cầu một Nhãn CostCenter.\nmanifests/modules/security/kyverno/simple-policy/require-labels-policy.yaml Kyverno có 2 loại tài nguyên Chính sách, ClusterPolicy được sử dụng cho Tài nguyên Toàn cụm và Policy được sử dụng cho Tài nguyên Thuộc vùng. Ví dụ trên hiển thị một ClusterPolicy. Dành một ít thời gian để đào sâu và kiểm tra các chi tiết dưới đây trong cấu hình.\nDưới phần spec của Chính sách, có một thuộc tính validationFailureAction nó cho biết cho Kyverno nếu tài nguyên đang được xác nhận nên được cho phép nhưng được báo cáo Audit hoặc bị chặn Enforce. Mặc định là Audit, ví dụ được đặt thành Enforce. rules là một hoặc nhiều quy tắc để được xác nhận. Tuyên bố match thiết lập phạm vi của những gì sẽ được kiểm tra. Trong trường hợp này, nó là bất kỳ tài nguyên Pod nào. Tuyên bố validate cố gắng kiểm tra tích cực những gì được xác định. Nếu tuyên bố, khi so sánh với tài nguyên yêu cầu, là đúng, nó được phép. Nếu sai, nó bị chặn. message là điều gì sẽ được hiển thị cho người dùng nếu quy tắc này không vượt qua xác nhận. Đối tượng pattern định nghĩa mẫu nào sẽ được kiểm tra trong tài nguyên. Trong trường hợp này, nó đang tìm kiếm metadata.labels với CostCenter. Chính sách Ví dụ ở trên sẽ chặn bất kỳ việc tạo Pod nào không có nhãn CostCenter.\nTạo chính sách bằng lệnh sau.\n$ kubectl apply -f ~/environment/eks-workshop/modules/security/kyverno/simple-policy/require-labels-policy.yaml clusterpolicy.kyverno.io/require-labels created Tiếp theo, hãy xem các Pod đang chạy trong không gian tên ui, chú ý các nhãn đã áp dụng.\n$ kubectl -n ui get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS ui-67d8cf77cf-d4j47 1/1 Running 0 9m app.kubernetes.io/component=service,app.kubernetes.io/created-by=eks-workshop,app.kubernetes.io/instance=ui,app.kubernetes.io/name=ui,pod-template-hash=67d8cf77cf Kiểm tra Pod đang chạy không có Nhãn được yêu cầu và Kyverno không chấm dứt nó, điều này xảy ra vì như đã thấy trước đó, Kyverno hoạt động như một AdmissionController và sẽ không can thiệp vào các tài nguyên đã tồn tại trong cụm.\nTuy nhiên, nếu bạn xóa Pod đang chạy, nó sẽ không thể được tạo lại vì nó không có Nhãn được yêu cầu. Hãy tiến hành xóa Pod đang chạy trong không gian tên ui.\n$ kubectl -n ui delete pod --all pod \u0026#34;ui-67d8cf77cf-d4j47\u0026#34; deleted $ kubectl -n ui get pods No resources found in ui namespace. Như đã đề cập, Pod không được tạo lại, hãy thử buộc một cuộc triển khai của ui.\n$ kubectl -n ui rollout restart deployment/ui error: failed to patch: admission webhook \u0026#34;validate.kyverno.svc-fail\u0026#34; denied the request: resource Deployment/ui/ui was blocked due to the following policies require-labels: autogen-check-team: \u0026#39;validation error: Label \u0026#39;\u0026#39;CostCenter\u0026#39;\u0026#39; is required to deploy the Pod. rule autogen-check-team failed at path /spec/template/metadata/labels/CostCenter/\u0026#39; Cuộc triển khai thất bại với webhook thẩm định từ chối yêu cầu do Chính sách Kyverno require-labels.\nBạn cũng có thể kiểm tra thông báo lỗi này mô tả việc triển khai ui, hoặc hiển thị sự kiện trong không gian tên ui.\n$ kubectl -n ui describe deployment ui ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning PolicyViolation 12m (x2 over 9m) kyverno-scan policy require-labels/autogen-check-team fail: validation error: Label \u0026#39;CostCenter\u0026#39; is required to deploy the Pod. rule autogen-check-team failed at path /spec/template/metadata/labels/CostCenter/ $ kubectl -n ui get events | grep PolicyViolation 9m Warning PolicyViolation pod/ui-67d8cf77cf-hvqcd policy require-labels/check-team fail: validation error: Label \u0026#39;CostCenter\u0026#39; is required to deploy the Pod. rule check-team failed at path /metadata/labels/CostCenter/ 9m Warning PolicyViolation replicaset/ui-67 d8cf77cf policy require-labels/autogen-check-team fail: validation error: Label \u0026#39;CostCenter\u0026#39; is required to deploy the Pod. rule autogen-check-team failed at path /spec/template/metadata/labels/CostCenter/ 9m Warning PolicyViolation deployment/ui policy require-labels/autogen-check-team fail: validation error: Label \u0026#39;CostCenter\u0026#39; is required to deploy the Pod. rule autogen-check-team failed at path /spec/template/metadata/labels/CostCenter/ Bây giờ thêm nhãn yêu cầu CostCenter vào ui Deployment, sử dụng bản vá Kustomization dưới đây.\nmodules/security/kyverno/simple-policy/ui-labeled/deployment.yaml\rDeployment/ui $ kubectl apply -k ~/environment/eks-workshop/modules/security/kyverno/simple-policy/ui-labeled namespace/ui unchanged serviceaccount/ui unchanged configmap/ui unchanged service/ui unchanged deployment.apps/ui configured $ kubectl -n ui rollout status deployment/ui $ kubectl -n ui get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS ui-5498685db8-k57nk 1/1 Running 0 60s CostCenter=IT,app.kubernetes.io/component=service,app.kubernetes.io/created-by=eks-workshop,app.kubernetes.io/instance=ui,app.kubernetes.io/name=ui,pod-template-hash=5498685db8 Như bạn có thể thấy, webhook thẩm định đã xác nhận chính sách và Pod được tạo ra với Nhãn chính xác CostCenter=IT!\nQuy tắc Chuyển đổi Trong các ví dụ trên, bạn đã kiểm tra cách Chính sách Xác nhận hoạt động trong hành vi mặc định của chúng được xác định trong validationFailureAction. Tuy nhiên, Kyverno cũng có thể được sử dụng để quản lý các quy tắc Chuyển đổi trong Chính sách, để sửa đổi bất kỳ Yêu cầu API nào để đáp ứng hoặc bắt buộc các yêu cầu cụ thể trên các tài nguyên Kubernetes. Việc biến đổi tài nguyên xảy ra trước khi xác nhận, vì vậy các quy tắc xác nhận sẽ không mâu thuẫn với các thay đổi thực hiện bởi phần mutation.\nDưới đây là một Chính sách mẫu có một quy tắc biến đổi được xác định, sẽ được sử dụng để tự động thêm nhãn mặc định CostCenter=IT của chúng tôi vào bất kỳ Pod nào.\nmanifests/modules/security/kyverno/simple-policy/add-labels-mutation-policy.yaml Chú ý phần mutate, dưới spec của ClusterPolicy.\nHãy tiến hành và tạo Chính sách trên bằng lệnh sau.\n$ kubectl apply -f ~/environment/eks-workshop/modules/security/kyverno/simple-policy/add-labels-mutation-policy.yaml clusterpolicy.kyverno.io/add-labels created Để xác nhận Webhook Chuyển đổi, lần này hãy triển khai lại assets Deployment mà không chỉ định rõ một nhãn:\n$ kubectl -n assets rollout restart deployment/assets deployment.apps/assets restarted $ kubectl -n assets rollout status deployment/assets deployment \u0026#34;assets\u0026#34; successfully rolled out Xác nhận nhãn CostCenter=IT được tự động thêm vào Pod để đáp ứng yêu cầu chính sách, dẫn đến việc tạo Pod thành công ngay cả khi Deployment không có nhãn được chỉ định:\n$ kubectl -n assets get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS assets-bb88b4789-kmk62 1/1 Running 0 25s CostCenter=IT,app.kubernetes.io/component=service,app.kubernetes.io/created-by=eks-workshop,app.kubernetes.io/instance=assets,app.kubernetes.io/name=assets,pod-template-hash=bb88b4789 Cũng có thể biến đổi các tài nguyên hiện có trong Cụm Amazon EKS của bạn bằng các Chính sách Kyverno sử dụng các tham số patchStrategicMerge và patchesJson6902 trong Chính sách Kyverno của bạn.\nĐó chỉ là một ví dụ đơn giản về các nhãn cho các Pod của chúng tôi với các quy tắc Xác nhận và Chuyển đổi. Điều này có thể được áp dụng vào các tình huống khác nhau như hạn chế Hình ảnh từ các kho lưu trữ không xác định, thêm Dữ liệu vào Bản đồ Cấu hình, Tolerations và nhiều hơn nữa. Trong các bài thực hành tiếp theo, bạn sẽ đi qua một số trường hợp sử dụng nâng cao hơn.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Kubernetes là một nền tảng nguồn mở, khả chuyển, có thể mở rộng để quản lý các ứng dụng được đóng gói và các service, giúp thuận lợi trong việc cấu hình và tự động hoá việc triển khai ứng dụng. Kubernetes là một hệ sinh thái lớn và phát triển nhanh chóng. Các dịch vụ, sự hỗ trợ và công cụ có sẵn rộng rãi.\nTên gọi Kubernetes có nguồn gốc từ tiếng Hy Lạp, có ý nghĩa là người lái tàu hoặc hoa tiêu. Google mở mã nguồn Kubernetes từ năm 2014. Kubernetes xây dựng dựa trên một thập kỷ rưỡi kinh nghiệm mà Google có được với việc vận hành một khối lượng lớn workload trong thực tế, kết hợp với các ý tưởng và thực tiễn tốt nhất từ cộng đồng.\nQuay ngược thời gian Chúng ta hãy xem tại sao Kubernetes rất hữu ích bằng cách quay ngược thời gian.\nThời đại triển khai theo cách truyền thống: Ban đầu, các ứng dụng được chạy trên các máy chủ vật lý. Không có cách nào để xác định ranh giới tài nguyên cho các ứng dụng trong máy chủ vật lý và điều này gây ra sự cố phân bổ tài nguyên. Ví dụ, nếu nhiều ứng dụng cùng chạy trên một máy chủ vật lý, có thể có những trường hợp một ứng dụng sẽ chiếm phần lớn tài nguyên hơn và kết quả là các ứng dụng khác sẽ hoạt động kém đi. Một giải pháp cho điều này sẽ là chạy từng ứng dụng trên một máy chủ vật lý khác nhau. Nhưng giải pháp này không tối ưu vì tài nguyên không được sử dụng đúng mức và rất tốn kém cho các tổ chức để có thể duy trì nhiều máy chủ vật lý như vậy.\nThời đại triển khai ảo hóa: Như một giải pháp, ảo hóa đã được giới thiệu. Nó cho phép bạn chạy nhiều Máy ảo (VM) trên CPU của một máy chủ vật lý. Ảo hóa cho phép các ứng dụng được cô lập giữa các VM và cung cấp mức độ bảo mật vì thông tin của một ứng dụng không thể được truy cập tự do bởi một ứng dụng khác.\nẢo hóa cho phép sử dụng tốt hơn các tài nguyên trong một máy chủ vật lý và cho phép khả năng mở rộng tốt hơn vì một ứng dụng có thể được thêm hoặc cập nhật dễ dàng, giảm chi phí phần cứng và hơn thế nữa. Với ảo hóa, bạn có thể có một tập hợp các tài nguyên vật lý dưới dạng một cụm các máy ảo sẵn dùng.\nMỗi VM là một máy tính chạy tất cả các thành phần, bao gồm cả hệ điều hành riêng của nó, bên trên phần cứng được ảo hóa.\nThời đại triển khai Container: Các container tương tự như VM, nhưng chúng có tính cô lập để chia sẻ Hệ điều hành (HĐH) giữa các ứng dụng. Do đó, container được coi là nhẹ (lightweight). Tương tự như VM, một container có hệ thống tệp (filesystem), CPU, bộ nhớ, process space, v.v. Khi chúng được tách rời khỏi cơ sở hạ tầng bên dưới, chúng có thể khả chuyển (portable) trên cloud hoặc các bản phân phối Hệ điều hành.\nCác container đã trở nên phổ biến vì chúng có thêm nhiều lợi ích, chẳng hạn như:\nTạo mới và triển khai ứng dụng Agile: gia tăng tính dễ dàng và hiệu quả của việc tạo các container image so với việc sử dụng VM image. Phát triển, tích hợp và triển khai liên tục: cung cấp khả năng build và triển khai container image thường xuyên và đáng tin cậy với việc rollbacks dễ dàng, nhanh chóng. Phân biệt giữa Dev và Ops: tạo các images của các application container tại thời điểm build/release thay vì thời gian triển khai, do đó phân tách các ứng dụng khỏi hạ tầng. Khả năng quan sát không chỉ hiển thị thông tin và các metric ở mức Hệ điều hành, mà còn cả application health và các tín hiệu khác. Tính nhất quán về môi trường trong suốt quá trình phát triển, testing và trong production: Chạy tương tự trên laptop như trên cloud. Tính khả chuyển trên cloud và các bản phân phối HĐH: Chạy trên Ubuntu, RHEL, CoreOS, on-premises, Google Kubernetes Engine và bất kì nơi nào khác. Quản lý tập trung ứng dụng: Tăng mức độ trừu tượng từ việc chạy một Hệ điều hành trên phần cứng ảo hóa sang chạy một ứng dụng trên một HĐH bằng logical resources. Các micro-services phân tán, elastic: ứng dụng được phân tách thành các phần nhỏ hơn, độc lập và thể được triển khai và quản lý một cách linh hoạt - chứ không phải một app nguyên khối (monolithic). Cô lập các tài nguyên: dự đoán hiệu năng ứng dụng Sử dụng tài nguyên: hiệu quả Tại sao bạn cần Kubernetes và nó có thể làm những gì? Các container là một cách tốt để đóng gói và chạy các ứng dụng của bạn. Trong môi trường production, bạn cần quản lý các container chạy các ứng dụng và đảm bảo rằng không có khoảng thời gian downtime. Ví dụ, nếu một container bị tắt đi, một container khác cần phải khởi động lên. Điều này sẽ dễ dàng hơn nếu được xử lý bởi một hệ thống.\nĐó là cách Kubernetes đến với chúng ta. Kubernetes cung cấp cho bạn một framework để chạy các hệ phân tán một cách mạnh mẽ. Nó đảm nhiệm việc nhân rộng và chuyển đổi dự phòng cho ứng dụng của bạn, cung cấp các mẫu deployment và hơn thế nữa. Ví dụ, Kubernetes có thể dễ dàng quản lý một triển khai canary cho hệ thống của bạn.\nKubernetes cung cấp cho bạn:\nService discovery và cân bằng tải\nKubernetes có thể expose một container sử dụng DNS hoặc địa chỉ IP của riêng nó. Nếu lượng traffic truy cập đến một container cao, Kubernetes có thể cân bằng tải và phân phối lưu lượng mạng (network traffic) để việc triển khai được ổn định. Điều phối bộ nhớ\nKubernetes cho phép bạn tự động mount một hệ thống lưu trữ mà bạn chọn, như local storages, public cloud providers, v.v. Tự động rollouts và rollbacks\nBạn có thể mô tả trạng thái mong muốn cho các container được triển khai dùng Kubernetes và nó có thể thay đổi trạng thái thực tế sang trạng thái mong muốn với tần suất được kiểm soát. Ví dụ, bạn có thể tự động hoá Kubernetes để tạo mới các container cho việc triển khai của bạn, xoá các container hiện có và áp dụng tất cả các resource của chúng vào container mới. Đóng gói tự động\nBạn cung cấp cho Kubernetes một cluster gồm các node mà nó có thể sử dụng để chạy các tác vụ được đóng gói (containerized task). Bạn cho Kubernetes biết mỗi container cần bao nhiêu CPU và bộ nhớ (RAM). Kubernetes có thể điều phối các container đến các node để tận dụng tốt nhất các resource của bạn. Tự phục hồi\nKubernetes khởi động lại các containers bị lỗi, thay thế các container, xoá các container không phản hồi lại cấu hình health check do người dùng xác định và không cho các client biết đến chúng cho đến khi chúng sẵn sàng hoạt động. Quản lý cấu hình và bảo mật\nKubernetes cho phép bạn lưu trữ và quản lý các thông tin nhạy cảm như: password, OAuth token và SSH key. Bạn có thể triển khai và cập nhật lại secret và cấu hình ứng dụng mà không cần build lại các container image và không để lộ secret trong cấu hình stack của bạn. Kubernetes không phải là gì? Kubernetes không phải là một hệ thống PaaS (Nền tảng như một Dịch vụ) truyền thống, toàn diện. Do Kubernetes hoạt động ở tầng container chứ không phải ở tầng phần cứng, nó cung cấp một số tính năng thường áp dụng chung cho các dịch vụ PaaS, như triển khai, nhân rộng, cân bằng tải, ghi nhật ký và giám sát. Tuy nhiên, Kubernetes không phải là cấu trúc nguyên khối và các giải pháp mặc định này là tùy chọn và có thể cắm được (pluggable).\nKubernetes:\nKhông giới hạn các loại ứng dụng được hỗ trợ. Kubernetes nhằm mục đích hỗ trợ một khối lượng công việc cực kỳ đa dạng, bao gồm cả stateless, stateful và xử lý dữ liệu. Nếu một ứng dụng có thể chạy trong một container, nó sẽ chạy rất tốt trên Kubernetes. Không triển khai mã nguồn và không build ứng dụng của bạn. Quy trình CI/CD được xác định bởi tổ chức cũng như các yêu cầu kỹ thuật. Không cung cấp các service ở mức ứng dụng, như middleware (ví dụ, các message buses), các framework xử lý dữ liệu (ví dụ, Spark), cơ sở dữ liệu (ví dụ, MySQL), bộ nhớ cache, cũng như hệ thống lưu trữ của cluster (ví dụ, Ceph). Các thành phần như vậy có thể chạy trên Kubernetes và/hoặc có thể được truy cập bởi các ứng dụng chạy trên Kubernetes thông qua các cơ chế di động, chẳng hạn như Open Service Broker. Không bắt buộc các giải pháp ghi lại nhật ký (logging), giám sát (monitoring) hoặc cảnh báo (alerting). Nó cung cấp một số sự tích hợp như proof-of-concept, và cơ chế để thu thập và xuất các số liệu. Không cung cấp, không bắt buộc một cấu hình ngôn ngữ/hệ thống (ví dụ: Jsonnet). Nó cung cấp một API khai báo có thể được targeted bởi các hình thức khai báo tùy ý. Không cung cấp cũng như áp dụng bất kỳ cấu hình toàn diện, bảo trì, quản lý hoặc hệ thống tự phục hồi. Ngoài ra, Kubernetes không phải là một hệ thống điều phối đơn thuần. Trong thực tế, nó loại bỏ sự cần thiết của việc điều phối. Định nghĩa kỹ thuật của điều phối là việc thực thi một quy trình công việc được xác định: đầu tiên làm việc A, sau đó là B rồi sau chót là C. Ngược lại, Kubernetes bao gồm một tập các quy trình kiểm soát độc lập, có thể kết hợp, liên tục điều khiển trạng thái hiện tại theo trạng thái mong muốn đã cho. Nó không phải là vấn đề làm thế nào bạn có thể đi được từ A đến C. Kiểm soát tập trung cũng không bắt buộc. Điều này dẫn đến một hệ thống dễ sử dụng hơn, mạnh mẽ hơn, linh hoạt hơn và có thể mở rộng. "
},
{
	"uri": "//localhost:1313/vi/4-amazon-eks-pod-identity/4.1-introduction/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Giới thiệu Thành phần carts trong kiến trúc của chúng tôi sử dụng Amazon DynamoDB làm nền tảng lưu trữ, đây là một trường hợp sử dụng phổ biến bạn sẽ tìm thấy cho việc tích hợp cơ sở dữ liệu không quan hệ với Amazon EKS. Cách mà API của carts đang triển khai hiện nay sử dụng một phiên bản nhẹ của Amazon DynamoDB chạy như một container trong cụm EKS.\nBạn có thể thấy điều này bằng cách chạy lệnh sau:\n$ kubectl -n carts get pod NAME READY STATUS RESTARTS AGE carts-5d7fc9d8f-xm4hs 1/1 Running 0 14m carts-dynamodb-698674dcc6-hw2bg 1/1 Running 0 14m Trong trường hợp trên, Pod carts-dynamodb-698674dcc6-hw2bg là dịch vụ DynamoDB nhẹ của chúng tôi. Chúng ta có thể xác minh ứng dụng carts của chúng ta đang sử dụng nó bằng cách kiểm tra môi trường của nó:\n$ kubectl -n carts exec deployment/carts -- env | grep CARTS_DYNAMODB_ENDPOINT CARTS_DYNAMODB_ENDPOINT=http://carts-dynamodb:8000 Cách tiếp cận này có thể hữu ích cho việc kiểm thử, nhưng chúng tôi muốn di chuyển ứng dụng của mình để sử dụng dịch vụ Amazon DynamoDB quản lý hoàn toàn để tận dụng đầy đủ quy mô và độ tin cậy mà nó cung cấp.\n"
},
{
	"uri": "//localhost:1313/vi/7-pod-security-standards/7.1-privileged-pss-profile/",
	"title": "Khám phá hồ sơ PSS",
	"tags": [],
	"description": "",
	"content": "Khám phá hồ sơ PSS Chúng ta sẽ bắt đầu khám phá hồ sơ Privileged (PSS) bằng cách khám phá hồ sơ Privileged, là hồ sơ linh hoạt nhất và cho phép việc nâng cao đặc quyền đã biết.\nKể từ phiên bản Kubernetes 1.23, theo mặc định, tất cả các chế độ PSA (tức là enforce, audit và warn) đều được kích hoạt cho hồ sơ PSS Privileged ở cấp độ cluster. Điều đó có nghĩa, theo mặc định, PSA cho phép triển khai (Deployments) hoặc các Pod với hồ sơ PSS Privileged (tức là không có bất kỳ hạn chế nào) trên tất cả các không gian tên (namespace). Các thiết lập mặc định này cung cấp ít ảnh hưởng đến các cluster và giảm thiểu tác động tiêu cực đối với các ứng dụng. Như chúng ta sẽ thấy, nhãn Namespace có thể được sử dụng để lựa chọn vào các thiết lập hạn chế hơn.\nBạn có thể kiểm tra xem không có nhãn PSA nào được thêm vào không gian tên assets, theo mặc định:\n$ kubectl describe ns assets Name: assets Labels: app.kubernetes.io/created-by=eks-workshop kubernetes.io/metadata.name=assets Annotations: \u0026lt;none\u0026gt; Status: Active No resource quota. No LimitRange resource. Như bạn thấy, không gian tên assets không có bất kỳ nhãn PSA nào được đính kèm.\nHãy cũng kiểm tra xem Triển khai (Deployment) và Pod đang chạy hiện tại trong không gian tên assets.\n$ kubectl -n assets get deployment NAME READY UP-TO-DATE AVAILABLE AGE assets 1/1 1 1 5m24s $ kubectl -n assets get pod NAME READY STATUS RESTARTS AGE assets-ddb8f87dc-8z6l9 1/1 Running 0 5m24s YAML cho Pod assets sẽ cho chúng ta thấy cấu hình bảo mật hiện tại:\n$ kubectl -n assets get deployment assets -o yaml | yq \u0026#39;.spec.template.spec\u0026#39; containers: - envFrom: - configMapRef: name: assets image: public.ecr.aws/aws-containers/retail-store-sample-assets:0.4.0 imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 3 httpGet: path: /health.html port: 8080 scheme: HTTP periodSeconds: 3 successThreshold: 1 timeoutSeconds: 1 name: assets ports: - containerPort: 8080 name: http protocol: TCP resources: limits: memory: 128Mi requests: cpu: 128m memory: 128Mi securityContext: capabilities: drop: - ALL readOnlyRootFilesystem: false terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /tmp name: tmp-volume dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} serviceAccount: assets serviceAccountName: assets terminationGracePeriodSeconds: 30 volumes: - emptyDir: medium: Memory name: tmp-volume Trong cấu hình bảo mật Pod trên, securityContext là nil ở cấp độ Pod. Ở cấp độ container, securityContext được cấu hình để loại bỏ tất cả các khả năng Linux và readOnlyRootFilesystem được đặt thành false. Việc triển khai và Pod đã chạy cho thấy rằng PSA (được cấu hình cho hồ sơ PSS Privileged theo mặc định) đã cho phép cấu hình bảo mật Pod trên.\nNhưng các điều kiện bảo mật khác mà PSA này cho phép là gì? Để kiểm tra điều đó, hãy thêm một số quyền hạn khác vào cấu hình bảo mật Pod trên và kiểm tra xem PSA có vẫn cho phép nó hay không trong không gian tên assets. Cụ thể, hãy thêm các cờ privileged và runAsUser:0 vào Pod trên, điều này có nghĩa là nó có thể truy cập vào tài nguyên máy chủ mà thường được yêu cầu cho các công việc như các agent giám sát và các sidecar của mạng dịch vụ, và cũng được phép chạy dưới dạng người dùng root:\nmodules/security/pss-psa/privileged-workload/deployment.yaml\rDeployment/assets Chạy Kustomize để áp dụng các thay đổi trên và kiểm tra xem PSA có cho phép Pod với các quyền hạn bảo mật trên hay không.\n$ kubectl apply -k ~/environment/eks-workshop/modules/security/pss-psa/privileged-workload namespace/assets unchanged serviceaccount/assets unchanged configmap/assets unchanged service/assets unchanged deployment.apps/assets configured Hãy kiểm tra xem Triển khai và Pod có được tạo lại với các quyền hạn bảo mật trên trong không gian tên assets không\n$ kubectl -n assets get pod NAME READY STATUS RESTARTS AGE assets-64c49f848b-gmrt t 1/1 Running 0 9s $ kubectl -n assets exec $(kubectl -n assets get pods -o name) -- whoami root Điều này cho thấy rằng chế độ PSA mặc định được kích hoạt cho hồ sơ PSS Privileged là phù hợp và cho phép các Pod yêu cầu quyền hạn bảo mật nâng cao nếu cần.\nLưu ý rằng các quyền hạn bảo mật trên không phải là danh sách toàn diện của các điều khiển cho phép trong hồ sơ PSS Privileged. Để biết chi tiết về các điều khiển bảo mật được phép/từ chối dưới mỗi hồ sơ PSS, hãy tham khảo tài liệu.\n"
},
{
	"uri": "//localhost:1313/vi/6-amazon-guardduty-for-eks/6.1-enable-guardduty-protection-on-eks/",
	"title": "Kích hoạt lớp bảo vệ GuardDuty trên EKS",
	"tags": [],
	"description": "",
	"content": "Trong lab này, chúng ta sẽ kích hoạt Amazon GuardDuty EKS Protection. Điều này sẽ cung cấp phạm vi phát hiện mối đe dọa cho EKS Audit Log Monitoring và EKS Runtime Monitoring để giúp bảo vệ các cụm của bạn.\nEKS Audit Log Monitoring sử dụng các log kiểm tra của Kubernetes để ghi lại các hoạt động theo thứ tự thời gian từ người dùng, ứng dụng sử dụng API Kubernetes và mặt bằng điều khiển để tìm kiếm các hoạt động có thể nghi ngờ.\nEKS Runtime Monitoring sử dụng các sự kiện cấp độ hệ điều hành để giúp bạn phát hiện các mối đe dọa tiềm ẩn trong các nút và container Amazon EKS.\nKích hoạt Amazon GuardDuty qua AWS CLI\n$ aws guardduty create-detector --enable --features \u0026#39;[{\u0026#34;Name\u0026#34; : \u0026#34;EKS_AUDIT_LOGS\u0026#34;, \u0026#34;Status\u0026#34; : \u0026#34;ENABLED\u0026#34;}, {\u0026#34;Name\u0026#34; : \u0026#34;EKS_RUNTIME_MONITORING\u0026#34;, \u0026#34;Status\u0026#34; : \u0026#34;ENABLED\u0026#34;, \u0026#34;AdditionalConfiguration\u0026#34; : [{\u0026#34;Name\u0026#34; : \u0026#34;EKS_ADDON_MANAGEMENT\u0026#34;, \u0026#34;Status\u0026#34; : \u0026#34;ENABLED\u0026#34;}]}]\u0026#39; { \u0026#34;DetectorId\u0026#34;: \u0026#34;1qaz0p2wsx9ol3edc8ik4rfv7ujm5tgb6yhn\u0026#34; } Kích hoạt Amazon GuardDuty qua AWS Console\nTruy cập Bảng điều khiển Amazon GuardDuty\nNhấp vào nút Get Started.\nNhấp vào Enable GuardDuty\nTruy cập EKS Protection trên menu bên trái và kiểm tra lại rằng Bảo vệ EKS đã được kích hoạt cho cả hai Audit Logs và Runtime Monitoring.\nHãy kiểm tra tab EKS clusters runtime coverage..\nNếu cụm của bạn không xuất hiện trong danh sách Cụm hoặc thống kê phạm vi không hiển thị 1/1 (100%), hãy đợi thêm vài phút để Amazon GuardDuty hoàn thành việc triển khai mô hình giám sát.\nBạn cũng có thể xác nhận việc triển khai Pod aws-guardduty-agent trong Cụm EKS của bạn.\n$ kubectl -n amazon-guardduty get pods NAME READY STATUS RESTARTS AGE aws-guardduty-agent-h7qg5 1/1 Running 0 58s aws-guardduty-agent-hgbsg 1/1 Running 0 58s aws-guardduty-agent-k7x2b 1/1 Running 0 58s Sau đó, truy cập Findings trên menu bên trái. Bạn sẽ thấy rằng chưa có phát hiện nào có sẵn.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.1-kubernetes-security-primitives/",
	"title": "Kubernetes Security Primitives",
	"tags": [],
	"description": "",
	"content": "Kubernetes Security Primitives Secure Hosts Secure Kubernetes Chúng ta cần đưa ra hai loại quyết định:\nAi có thể truy cập? Họ có thể làm gì? Xác thực (Authentication) Ai có thể truy cập vào máy chủ API được xác định bởi các cơ chế xác thực. Ủy quyền (Authorization) Sau khi họ có quyền truy cập vào cụm, những gì họ có thể làm được được xác định bởi các cơ chế ủy quyền. Chứng chỉ TLS Tất cả các giao tiếp với cụm, giữa các thành phần khác nhau như Cụm ETCD, kube-controller-manager, lập lịch, máy chủ API, cũng như những thành phần đang chạy trên các nút làm việc như kubelet và kubeproxy đều được bảo vệ bằng mã hóa TLS. Chính sách Mạng Cách giao tiếp giữa các ứng dụng trong cụm.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Kubernetes trên AWS",
	"tags": [],
	"description": "",
	"content": "Kubernetes trên AWS Kubernetes là một nền tảng mã nguồn mở, linh hoạt, có khả năng mở rộng, phục vụ việc quản lý các ứng dụng được đóng gói và các dịch vụ liên quan, giúp việc cấu hình và tự động hóa quá trình triển khai ứng dụng trở nên thuận tiện hơn. Được biết đến như một hệ sinh thái lớn và phát triển nhanh chóng, Kubernetes cung cấp sự hỗ trợ rộng rãi qua các dịch vụ và công cụ đa dạng.\nTên Kubernetes bắt nguồn từ tiếng Hy Lạp, nghĩa là người lái tàu hoặc hoa tiêu. Kubernetes được Google công bố mã nguồn vào năm 2014, dựa trên gần một thập kỷ kinh nghiệm quản lý workload lớn trong thực tế của Google, kết hợp với các ý tưởng và best practices từ cộng đồng.\nQuay ngược thời gian Hãy xem xét tại sao Kubernetes lại quan trọng thông qua việc nhìn lại quá khứ.\nThời kỳ triển khai truyền thống: Ban đầu, các ứng dụng được chạy trực tiếp trên máy chủ vật lý, khiến việc phân bổ tài nguyên gặp khó khăn do không có cơ chế xác định ranh giới tài nguyên cho từng ứng dụng. Cách tiếp cận này dẫn đến nguy cơ một ứng dụng có thể sử dụng quá nhiều tài nguyên, ảnh hưởng đến hoạt động của các ứng dụng khác. Giải pháp là chạy mỗi ứng dụng trên một máy chủ vật lý riêng biệt, nhưng điều này lại không hiệu quả về mặt chi phí và tài nguyên.\nThời kỳ triển khai ảo hóa: Ảo hóa được giới thiệu như một giải pháp cho phép chạy nhiều Máy ảo (VM) trên cùng một máy chủ vật lý, giúp cô lập ứng dụng và tăng cường bảo mật. Ảo hóa cũng giúp cải thiện hiệu quả sử dụng tài nguyên và khả năng mở rộng.\nThời kỳ triển khai Container: Container giống như VM nhưng nhẹ hơn và chia sẻ Hệ điều hành (HĐH) với nhau. Container mang lại nhiều lợi ích như tạo mới và triển khai ứng dụng nhanh chóng, phát triển và triển khai liên tục, phân biệt rõ ràng giữa quá trình phát triển và vận hành, cung cấp tính nhất quán qua các môi trường, khả năng di chuyển giữa các cloud và HĐH, và quản lý ứng dụng tập trung.\nTại sao bạn cần Kubernetes và nó có thể làm gì? Container là phương tiện hiệu quả để đóng gói và chạy ứng dụng của bạn. Trong môi trường sản xuất, cần có cơ chế quản lý các container một cách hiệu quả, đảm bảo không có downtime. Kubernetes giúp quản lý các hệ thống phân tán mạnh mẽ, tự động hóa việc nhân rộng, cung cấp các mẫu triển khai và nhiều hơn nữa.\nKubernetes mang lại:\nPhát hiện dịch vụ và cân bằng tải Điều phối bộ nhớ Tự động rollouts và rollbacks Đóng gói tự động Tự phục hồi Quản lý cấu hình và bảo mật Những gì Kubernetes không phải là Kubernetes không phải là một hệ thống PaaS truyền thống, toàn diện. Nó hoạt động ở tầng container, cung cấp tính năng giống như PaaS như triển khai, nhân rộng, cân bằng tải, nhưng là một giải pháp linh hoạt và có thể mở rộng, không giới hạn loại ứng dụng được hỗ trợ, không triển khai mã nguồn hoặc build ứng dụng, không cung cấp dịch vụ ứng dụng cấp cao như middleware, databases, không bắt buộc sử dụng các giải pháp ghi nhật ký, giám sát hoặc cảnh báo, và không cung cấp hoặc áp dụng bất kỳ cấu hình toàn diện, bảo trì, quản lý hoặc hệ thống tự phục hồi. Kubernetes loại bỏ nhu cầu về điều phối truyền thống, thay vào đó là kiểm soát liên tục từ trạng thái hiện tại sang trạng thái mong muốn.\n"
},
{
	"uri": "//localhost:1313/vi/3-iam-roles-for-service-accounts/3.1-list-resource/",
	"title": "Liệt kê tài nguyên",
	"tags": [],
	"description": "",
	"content": "Liệt kê tài nguyên Giới thiệu Thành phần carts của kiến ​​trúc của chúng tôi sử dụng Amazon DynamoDB làm cơ sở dữ liệu lưu trữ của nó, đây là một trường hợp sử dụng phổ biến bạn sẽ thấy cho việc tích hợp cơ sở dữ liệu không quan hệ với Amazon EKS. Cách mà API carts hiện đang triển khai sử dụng một phiên bản nhẹ của Amazon DynamoDB chạy như một container trong cụm EKS.\nBạn có thể thấy điều này bằng cách chạy lệnh sau:\nkubectl -n carts get pod NAME READY STATUS RESTARTS AGE carts-5d7fc9d8f-xm4hs 1/1 Running 0 14m carts-dynamodb-698674dcc6-hw2bg 1/1 Running 0 14m Trong trường hợp trên, Pod carts-dynamodb-698674dcc6-hw2bg là dịch vụ DynamoDB nhẹ của chúng tôi. Chúng ta có thể xác minh ứng dụng giỏ hàng của chúng ta đang sử dụng nó bằng cách kiểm tra môi trường của nó:\nkubectl -n carts exec deployment/carts -- env | grep CARTS_DYNAMODB_ENDPOINT CARTS_DYNAMODB_ENDPOINT=http://carts-dynamodb:8000 Cách tiếp cận này có thể hữu ích cho việc kiểm thử, nhưng chúng tôi muốn di chuyển ứng dụng của mình để sử dụng dịch vụ Amazon DynamoDB quản lý hoàn toàn để tận dụng đầy đủ quy mô và độ tin cậy mà nó cung cấp.\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.3-securing-secrets-using-sealed-secrets/5.3.1-sealed-secrets-for-kubernetes/",
	"title": "Sealed Secret cho Kubernetes",
	"tags": [],
	"description": "",
	"content": "Sealed Secret cho Kubernetes Sealed Secrets bao gồm hai phần:\nMột controller phía cụm Một CLI phía khách gọi là kubeseal Khi controller khởi động, nó tìm kiếm một cặp khóa riêng tư/công khai trên toàn cụm và tạo một cặp khóa RSA 4096 bit mới nếu không tìm thấy. Khóa riêng được lưu trữ trong một đối tượng Secret trong cùng không gian tên với controller (mặc định là kube-system). Phần khóa công cộng của nó được công khai cho bất kỳ ai muốn sử dụng SealedSecrets với cụm này.\nTrong quá trình mã hóa, mỗi giá trị trong Secret gốc được mã hóa theo đối xứng bằng AES-256 bằng một khóa phiên được tạo ngẫu nhiên. Khóa phiên sau đó được mã hóa không đối xứng với khóa công cộng của controller bằng SHA256 và tên không gian/tên gốc của Secret làm tham số đầu vào. Đầu ra của quá trình mã hóa là một chuỗi được xây dựng như sau: độ dài (2 byte) của khóa phiên đã được mã hóa + khóa phiên đã được mã hóa + Secret đã được mã hóa\nKhi một tài nguyên tùy chỉnh SealedSecret được triển khai lên cụm Kubernetes, controller sẽ nhận nó, mở khóa nó bằng khóa riêng và tạo một tài nguyên Secret. Trong quá trình giải mã, không gian tên/tên của SealedSecret được sử dụng lại làm tham số đầu vào. Điều này đảm bảo rằng SealedSecret và Secret được chặt chẽ liên kết với cùng một không gian tên và tên.\nCông cụ CLI đồng hành, kubeseal, được sử dụng để tạo một định nghĩa tài nguyên tùy chỉnh SealedSecret (CRD) từ một định nghĩa tài nguyên Secret bằng cách sử dụng khóa công cộng. kubeseal có thể giao tiếp với controller thông qua máy chủ API Kubernetes và lấy khóa công cộng cần thiết để mã hóa một Secret trong thời gian chạy. Khóa công cộng cũng có thể được tải xuống từ controller và lưu trữ cục bộ để sử dụng offline.\nCác SealedSecrets có thể có ba phạm vi sau:\nstrict (mặc định): Secret phải được niêm phong với chính xác cùng tên và không gian tên. Các thuộc tính này trở thành một phần của dữ liệu đã mã hóa và do đó, việc thay đổi tên và/hoặc không gian tên sẽ dẫn đến \u0026ldquo;lỗi giải mã\u0026rdquo;. namespace-wide: Secret đã niêm phong có thể được đổi tên tự do trong một không gian tên cụ thể. cluster-wide: Secret có thể được mở niêm phong trong bất kỳ không gian tên nào và có thể được đặt bất kỳ tên nào. "
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.2-managing-secrets-with-aws-secrets-manager/5.2.1-storing-secrets-in-aws-secrets-manager/",
	"title": "Storing secrets in AWS Secrets Manager",
	"tags": [],
	"description": "",
	"content": "Storing secrets in AWS Secrets Manager Trước tiên, chúng ta cần lưu một khoá bí mật trong AWS Secrets Manager, hãy làm điều đó bằng cách sử dụng AWS CLI:\n$ export SECRET_SUFFIX=$(openssl rand -hex 4) $ export SECRET_NAME=\u0026#34;$EKS_CLUSTER_NAME-catalog-secret-${SECRET_SUFFIX}\u0026#34; $ aws secretsmanager create-secret --name \u0026#34;$SECRET_NAME\u0026#34; \\ --secret-string \u0026#39;{\u0026#34;username\u0026#34;:\u0026#34;catalog_user\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;default_password\u0026#34;}\u0026#39; --region $AWS_REGION { \u0026#34;ARN\u0026#34;: \u0026#34;arn:aws:secretsmanager:$AWS_REGION:$AWS_ACCOUNT_ID:secret:$EKS_CLUSTER_NAME/catalog-secret-ABCdef\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;eks-workshop/static-secret\u0026#34;, \u0026#34;VersionId\u0026#34;: \u0026#34;7e0b352d-6666-4444-aaaa-cec1f1d2df1b\u0026#34; } Lệnh trên đang lưu một khoá bí mật với nội dung key/value được mã hóa JSON, cho các thông tin username và password.\nXác thực bí mật mới đã lưu trong AWS Secrets Manager Console hoặc sử dụng lệnh này:\n$ aws secretsmanager describe-secret --secret-id \u0026#34;$SECRET_NAME\u0026#34; { \u0026#34;ARN\u0026#34;: \u0026#34;arn:aws:secretsmanager:us-west-2:068535243777:secret:eks-workshop/catalog-secret-WDD8yS\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;eks-workshop/catalog-secret\u0026#34;, \u0026#34;LastChangedDate\u0026#34;: \u0026#34;2023-10-10T20:44:51.882000+00:00\u0026#34;, \u0026#34;VersionIdsToStages\u0026#34;: { \u0026#34;94d1fe43-87f5-42fb-bf28-f6b090f0ca44\u0026#34;: [ \u0026#34;AWSCURRENT\u0026#34; ] }, \u0026#34;CreatedDate\u0026#34;: \u0026#34;2023-10-10T20:44:51.439000+00:00\u0026#34; } "
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.1-exploring-secrets/",
	"title": "Tìm hiểu khoá bí mật",
	"tags": [],
	"description": "",
	"content": "Tìm hiểu khoá bí mật Tiết lộ Secrets dưới dạng Environment Variables Có thể tiết lộ các khóa, chẳng hạn như, tên người dùng và mật khẩu, trong Secret database-credentials tới một Pod dưới dạng Environment Variables sử dụng một tài liệu Pod như sau (dưới đây):\napiVersion: v1 kind: Pod metadata: name: someName namespace: someNamespace spec: containers: - name: someContainer image: someImage env: - name: DATABASE_USER valueFrom: secretKeyRef: name: database-credentials key: username - name: DATABASE_PASSWORD valueFrom: secretKeyRef: name: database-credentials key: password Tiết lộ Secrets dưới dạng Volumes Secrets cũng có thể được gắn kết như các khối dữ liệu trên một Pod và bạn có thể kiểm soát các đường dẫn bên trong Volumes nơi các khóa Secret được chiếu ra sử dụng một tài liệu Pod như sau (dưới đây):\napiVersion: v1 kind: Pod metadata: name: someName namespace: someNamespace spec: containers: - name: someContainer image: someImage volumeMounts: - name: secret-volume mountPath: \u0026#34;/etc/data\u0026#34; readOnly: true volumes: - name: secret-volume secret: secretName: database-credentials items: - key: username path: DATABASE_USER - key: password path: DATABASE_PASSWORD Với đặc tả Pod trên, điều sau sẽ xảy ra:\nGiá trị cho khóa username trong Secret database-credentials được lưu trữ trong tệp /etc/data/DATABASE_USER bên trong Pod. Giá trị cho khóa mật khẩu được lưu trữ trong tệp /etc/data/DATABASE_PASSWORD. "
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.2-managing-secrets-with-aws-secrets-manager/5.2.2-ascp/",
	"title": "ASCP",
	"tags": [],
	"description": "",
	"content": "AWS Secrets and Configuration Provider (ASCP) Khi chúng ta thực thi kịch bản prepare-environment được mô tả trong một bước trước đó, nó đã cài đặt thành công AWS Secrets and Configuration Provider (ASCP) cho Kubernetes Secrets Store CSI Driver cần thiết cho bài thực hành này.\nTiếp theo, hãy kiểm tra xem các addons đã được triển khai hay chưa.\nKiểm tra DaemonSet và các Pods tương ứng của Kubernetes Secrets Store CSI Driver.\n$ kubectl -n secrets-store-csi-driver get pods,daemonsets -l app=secrets-store-csi-driver NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/csi-secrets-store-secrets-store-csi-driver 3 3 3 3 3 kubernetes.io/os=linux 3m57s NAME READY STATUS RESTARTS AGE pod/csi-secrets-store-secrets-store-csi-driver-bzddm 3/3 Running 0 3m57s pod/csi-secrets-store-secrets-store-csi-driver-k7m6c 3/3 Running 0 3m57s pod/csi-secrets-store-secrets-store-csi-driver-x2rs4 3/3 Running 0 3m57s Kiểm tra DaemonSet và các Pods tương ứng của Driver CSI Secrets Store Provider cho AWS.\n$ kubectl -n kube-system get pods,daemonset -l \u0026#34;app=secrets-store-csi-driver-provider-aws\u0026#34; NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/secrets-store-csi-driver-provider-aws 3 3 3 3 3 kubernetes.io/os=linux 2m3s NAME READY STATUS RESTARTS AGE pod/secrets-store-csi-driver-provider-aws-4jf8f 1/1 Running 0 2m2s pod/secrets-store-csi-driver-provider-aws-djtf5 1/1 Running 0 2m2s pod/secrets-store-csi-driver-provider-aws-dzg9r 1/1 Running 0 2m2s Để cung cấp quyền truy cập vào các khoá bí mật được lưu trữ trong AWS Secrets Manager qua Kubernetes Secrets Store CSI Driver, bạn cần một SecretProviderClass, đây là một tài nguyên tùy chỉnh có phạm vi được sử dụng để cung cấp cấu hình của trình điều khiển và các tham số cụ thể phù hợp với thông tin trong AWS Secrets Manager.\nmanifests/modules/security/secrets-manager/secret-provider-class.yaml Trong tài nguyên trên, chúng ta có hai cấu hình chính mà chúng ta nên tập trung. Vì vậy, hãy tiến hành tạo tài nguyên để khám phá các thông số đó.\n$ cat ~/environment/eks-workshop/modules/security/secrets-manager/secret-provider-class.yaml \\ | envsubst | kubectl apply -f - Tham số objects, trỏ đến một khoá bí mật có tên là eks-workshop/catalog-secret mà chúng ta sẽ lưu trữ trong AWS Secrets Manager trong bước tiếp theo. Lưu ý rằng chúng tôi đang sử dụng jmesPath để trích xuất một cặp key-value cụ thể từ bí mật được định dạng JSON.\n$ kubectl get secretproviderclass -n catalog catalog-spc -o yaml | yq \u0026#39;.spec.parameters.objects\u0026#39; - objectName: \u0026#34;eks-workshop/catalog-secret\u0026#34; objectType: \u0026#34;secretsmanager\u0026#34; jmesPath: - path: username objectAlias: username - path: password objectAlias: password Và secretObjects, sẽ tạo và/hoặc đồng bộ hóa một Kubernetes Secrets với dữ liệu từ bí mật được lưu trữ trong AWS Secrets Manager. Điều này có nghĩa là khi được gắn vào một Pod, SecretProviderClass sẽ tạo ra một Kubernetes Secrets, nếu nó chưa tồn tại, và đồng bộ hóa các giá trị được lưu trữ trong AWS Secrets Manager với Kubernetes Secrets này, trong trường hợp của chúng ta, nó có tên là catalog-secret.\n$ kubectl get secretproviderclass -n catalog catalog-spc -o yaml | yq \u0026#39;.spec.secretObjects\u0026#39; - data: - key: username objectName: username - key: password objectName: password secretName: catalog-secret type: Opaque "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các Bước Chuẩn Bị",
	"tags": [],
	"description": "",
	"content": "Các Bước Chuẩn Bị IAM Roles cho Service Accounts Trước Khi Bắt Đầu Chuẩn bị môi trường cho phần này:\nprepare-environment security/irsa Điều này sẽ thực hiện các thay đổi sau vào môi trường lab của bạn:\nTạo một bảng Amazon DynamoDB Tạo một vai trò IAM cho các tải trọng công việc AmazonEKS để truy cập vào bảng DynamoDB Cài đặt AWS Load Balancer Controller trong cụm Amazon EKS Ứng dụng trong các container của Pod có thể sử dụng AWS SDK hoặc AWS CLI để thực hiện các yêu cầu API đến các dịch vụ AWS bằng quyền IAM. Ví dụ, ứng dụng có thể cần tải lên các tệp vào một bucket S3 hoặc truy vấn một bảng DynamoDB. Để làm điều này, các ứng dụng phải ký các yêu cầu API AWS của họ bằng thông tin đăng nhập AWS. IAM Roles cho Service Accounts (IRSA) cung cấp khả năng quản lý thông tin đăng nhập cho các ứng dụng của bạn, tương tự như cách các Hồ sơ Thể hiện IAM cung cấp thông tin đăng nhập cho các thể hiện Amazon EC2. Thay vì tạo và phân phối thông tin đăng nhập AWS của bạn cho các container hoặc phụ thuộc vào Hồ sơ Thể hiện Amazon EC2 để cấp quyền, bạn kết hợp một Vai trò IAM với một Tài khoản Dịch vụ Kubernetes và cấu hình Pods của bạn để sử dụng Tài khoản Dịch vụ đó.\nTrong chương này, chúng tôi sẽ cấu hình lại một trong các thành phần ứng dụng mẫu để tận dụng một API AWS và cung cấp cho nó xác thực phù hợp.\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.3-securing-secrets-using-sealed-secrets/5.3.2-installing-sealed-secrets/",
	"title": "Cài đặt Sealed Secrets",
	"tags": [],
	"description": "",
	"content": "Cài đặt Sealed Secrets Lệnh kubeseal được sử dụng để tương tác với bộ điều khiển sealed secrets, và đã được cài đặt sẵn trong Cloud9.\nĐiều đầu tiên chúng ta sẽ làm là cài đặt bộ điều khiển sealed secrets trong cụm EKS:\n$ kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml $ kubectl wait --for=condition=Ready --timeout=30s pods -l name=sealed-secrets-controller -n kube-system Bây giờ chúng ta sẽ kiểm tra trạng thái của pod\n$ kubectl get pods -n kube-system -l name=sealed-secrets-controller sealed-secrets-controller-77747c4b8c-snsxp 1/1 Running 0 5s Các bản log của bộ điều khiển sealed secrets cho thấy rằng bộ điều khiển cố gắng tìm bất kỳ khóa riêng nào hiện có trong quá trình khởi động. Nếu không có khóa riêng nào được tìm thấy, sau đó nó sẽ tạo một khoá bí mật mới với các chi tiết chứng chỉ.\n$ kubectl logs deployments/sealed-secrets-controller -n kube-system controller version: 0.18.0 2022/10/18 09:17:01 Starting sealed-secrets controller version: 0.18.0 2022/10/18 09:17:01 Searching for existing private keys 2022/10/18 09:17:02 New key written to kube-system/sealed-secrets-keyvkl9w 2022/10/18 09:17:02 Certificate is -----BEGIN CERTIFICATE----- MIIEzTCCArWgAwIBAgIRAPsk+UrW9GlPu4gXN1qKqGswDQYJKoZIhvcNAQELBQAw ADAeFw0yMjEwMTgwOTE3MDJaFw0zMjEwMTUwOTE3MDJaMAAwggIiMA0GCSqGSIb3 (...) q5P11EvxPBfIt9xDx5Jz4JWp5M7wWawGaeBqTmTDbSkc -----END CERTIFICATE----- 2022/10/18 09:17:02 HTTP server serving on :8080 Chúng ta có thể xem nội dung của khoá bí mật chứa khóa niêm phong dưới dạng cặp khóa công khai / khóa riêng trong định dạng YAML như sau:\n$ kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml apiVersion: v1 items: - apiVersion: v1 data: tls.crt: LS0tL(...)LQo= tls.key: LS0tL(...)LS0K kind: Secret metadata: creationTimestamp: \u0026#34;2022-10-18T09:17:02Z\u0026#34; generateName: sealed-secrets-key labels: sealedsecrets.bitnami.com/sealed-secrets-key: active name: sealed-secrets-keyvkl9w namespace: kube-system resourceVersion: \u0026#34;129381\u0026#34; uid: 23f5e70c-2537-4c38-a85c-b410f1dcf9a6 type: kubernetes.io/tls kind: List metadata: resourceVersion: \u0026#34;\u0026#34; selfLink: \u0026#34;\u0026#34; "
},
{
	"uri": "//localhost:1313/vi/8-policy-management-with-kyverno/8.2-enforcing-pod-security-standards/",
	"title": "Enforcing Pod Security Standards",
	"tags": [],
	"description": "",
	"content": "Như đã thảo luận trong phần Tiêu chuẩn Bảo mật Pod (PSS) giới thiệu, có 3 cấp độ Chính sách được xác định trước, Privileged (Đặc quyền), Baseline (Cơ sở), và Restricted (Hạn chế). Trong khi khuyến nghị cài đặt một PSS Hạn chế, điều này có thể gây ra hành vi không mong muốn ở cấp độ ứng dụng trừ khi được thiết lập đúng cách. Để bắt đầu, khuyến nghị cài đặt một Chính sách Baseline sẽ ngăn chặn các việc thăng cấp Đặc quyền đã biết như Containers truy cập HostProcess, HostPath, HostPorts hoặc cho phép theo dõi lưu lượng chẳng hạn, có thể thiết lập các chính sách cá nhân để hạn chế hoặc không cho phép truy cập đặc quyền đó vào các container.\nMột Chính sách Baseline Kyverno sẽ giúp hạn chế tất cả các việc thăng cấp đặc quyền đã biết dưới một chính sách duy nhất, và cũng duy trì và cập nhật Chính sách thường xuyên bổ sung các lỗ hổng mới nhất được tìm thấy vào Chính sách.\nCác container Privileged có thể làm gần như mọi thứ mà máy chủ có thể làm và thường được sử dụng trong các ống dẫn CI/CD để cho phép xây dựng và xuất bản hình ảnh Container. Với lỗi CVE-2022-23648 hiện đã được sửa, bất kỳ nhân vật xấu nào cũng có thể thoát khỏi container có đặc quyền bằng cách lạm dụng chức năng release_agent của Nhóm Kiểm soát để thực thi các lệnh tùy ý trên máy chủ container.\nTrong thí nghiệm này, chúng ta sẽ chạy một Pod có đặc quyền trên cụm EKS của chúng ta. Để làm điều đó, thực thi lệnh sau:\n$ kubectl run privileged-pod --image=nginx --restart=Never --privileged pod/privileged-pod created $ kubectl delete pod privileged-pod pod \u0026#34;privileged-pod\u0026#34; deleted Để tránh những khả năng có đặc quyền được thăng cấp như vậy và tránh việc sử dụng không được ủy quyền của các quyền trên, khuyến nghị cài đặt một Chính sách Baseline bằng cách sử dụng Kyverno.\nHồ sơ cơ sở của Tiêu chuẩn Bảo mật Pod là một bộ sưu tập các bước cơ bản và quan trọng nhất có thể được thực hiện để bảo mật Pods. Bắt đầu từ Kyverno 1.8, một hồ sơ hoàn chỉnh có thể được gán cho cụm thông qua một quy tắc duy nhất. Để kiểm tra thêm về các đặc quyền bị chặn bởi Hồ sơ Cơ sở, vui lòng tham khảo tại đây\nmanifests/modules/security/kyverno/baseline-policy/baseline-policy.yaml Lưu ý rằng chính sách trên đang ở chế độ Enforce, và sẽ chặn bất kỳ yêu cầu nào để tạo Pod có đặc quyền.\nTiến hành và áp dụng Chính sách Baseline.\n$ kubectl apply -f ~/environment/eks-workshop/modules/security/kyverno/baseline-policy/baseline-policy.yaml clusterpolicy.kyverno.io/baseline-policy created Bây giờ, hãy thử chạy lại Pod có đặc quyền.\n$ kubectl run privileged-pod --image=nginx --restart=Never --privileged Error from server: admission webhook \u0026#34;validate.kyverno.svc-fail\u0026#34; denied the request: resource Pod/default/privileged-pod was blocked due to the following policies baseline-policy: baseline: | Validation rule \u0026#39;baseline\u0026#39; failed. It violates PodSecurity \u0026#34;baseline:latest\u0026#34;: ({Allowed:false ForbiddenReason:privileged ForbiddenDetail:container \u0026#34;privileged-pod\u0026#34; must not set securityContext.privileged=true}) Như đã thấy, việc tạo không thành công, vì nó không tuân thủ với Chính sách Baseline của chúng tôi được thiết lập trên Cụm.\nLưu ý về Chính sách Tự tạo PSA hoạt động ở cấp độ Pod, nhưng trong thực tế Pods thường được quản lý bởi các điều khiển Pod, như Deployments. Không có chỉ dẫn về các lỗi bảo mật Pod ở cấp độ điều khiển Pod có thể làm cho các vấn đề trở nên phức tạp trong việc sửa lỗi. Chế độ áp dụng của PSA là chế độ duy nhất của PSA ngăn các Pod từ việc được tạo, tuy nhiên việc áp dụng PSA không hoạt động ở cấp độ điều khiển Pod. Để cải thi\nện trải nghiệm này, khuyến nghị sử dụng các chế độ cảnh báo và kiểm tra của PSA cùng với chế độ áp dụng. Với điều đó, PSA sẽ chỉ ra rằng các tài nguyên điều khiển đang cố gắng tạo các Pod sẽ thất bại với cấp độ PSS được áp dụng.\nSử dụng các giải pháp PaC với Kubernetes đặt ra một thách thức khác là viết và duy trì các chính sách để bao gồm tất cả các tài nguyên khác nhau được sử dụng trong các cụm. Với tính năng Quy tắc Tự tạo của Kyverno cho Các điều khiển Pod, các chính sách Pod sẽ tự động tạo ra các chính sách điều khiển Pod liên quan (Deployment, DaemonSet, v.v.). Tính năng của Kyverno này tăng tính biểu diễn của các chính sách và giảm bớt công sức để duy trì các chính sách cho các tài nguyên liên quan. cải thiện trải nghiệm người dùng PSA trong đó các tài nguyên điều khiển không bị ngăn cản khỏi tiến triển, trong khi các Pod cơ bản đều là.\n"
},
{
	"uri": "//localhost:1313/vi/6-amazon-guardduty-for-eks/6.2-eks-log-monitoring/",
	"title": "Giám sát log EKS",
	"tags": [],
	"description": "",
	"content": "Giám sát nhật ký kiểm tra EKS Khi kích hoạt, Trình Giám sát Nhật ký Kiểm tra EKS ngay lập tức bắt đầu giám sát nhật ký kiểm tra Kubernetes từ các cụm của bạn và phân tích chúng để phát hiện hoạt động có thể độc hại và nghi ngờ. Nó tiêu thụ các sự kiện nhật ký kiểm tra Kubernetes trực tiếp từ tính năng nhật ký điều khiển Amazon EKS thông qua một luồng nhật ký dòng độc lập và trùng lặp.\nTrong bài thực hành này, chúng ta sẽ tạo ra một số phát hiện giám sát kiểm tra Kubernetes trong cụm Amazon EKS của bạn, được liệt kê dưới đây.\nExecution:Kubernetes/ExecInKubeSystemPod Discovery:Kubernetes/SuccessfulAnonymousAccess Policy:Kubernetes/AnonymousAccessGranted Impact:Kubernetes/SuccessfulAnonymousAccess Policy:Kubernetes/AdminAccessToDefaultServiceAccount Policy:Kubernetes/ExposedDashboard PrivilegeEscalation:Kubernetes/PrivilegedContainer Persistence:Kubernetes/ContainerWithSensitiveMount Phát hiện này cho thấy rằng một lệnh đã được thực thi bên trong một Pod trong Namespace kube-system trên Cụm EKS.\nTrước tiên hãy chạy một Pod trong Namespace kube-system cung cấp truy cập vào môi trường shell của nó.\n$ kubectl -n kube-system run nginx --image=nginx $ kubectl wait --for=condition=ready pod nginx -n kube-system $ kubectl -n kube-system get pod nginx NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 28s Tiếp theo chạy lệnh dưới đây để tạo ra phát hiện Execution:Kubernetes/ExecInKubeSystemPod:\n$ kubectl -n kube-system exec nginx -- pwd / Trong vài phút, chúng ta sẽ thấy phát hiện Execution:Kubernetes/ExecInKubeSystemPod trên bảng điều khiển Findings của GuardDuty.\nNếu bạn nhấp vào phát hiện, nó sẽ mở một tab ở bên phải màn hình, hiển thị chi tiết về phát hiện và một giải thích ngắn gọn về nó.\nNó cũng cung cấp cho bạn lựa chọn để điều tra phát hiện bằng cách sử dụng Amazon Detective.\nMột thông tin quan trọng đáng xem xét là Hành động được phát hiện, trên mục này (Loại giám sát nhật ký), chúng ta có thể thấy rằng liên quan đến một KUBERNETES_API_CALL.\nDọn dẹp Pod gây ra phát hiện:\n$ kubectl -n kube-system delete pod nginx Trong bài thực hành tiếp theo này, chúng ta sẽ cấp quyền quản trị cụm cho một Tài khoản Dịch vụ. Điều này không phải là thực hành tốt vì có thể dẫn đến việc Các Pod được kết nối với Tài khoản Dịch vụ này được khởi chạy không cẩn thận với quyền quản trị, cho phép người dùng có quyền exec vào các Pod này, để leo thang và có quyền truy cập không hạn chế vào cụm.\nĐể mô phỏng điều này, chúng ta cần gán vai trò cluster-admin cho Tài khoản Dịch vụ default trong không gian tên default.\n$ kubectl -n default create rolebinding sa-default-admin --clusterrole cluster-admin --serviceaccount default:default Trong vài phút, bạn sẽ thấy phát hiện Policy:Kubernetes/AdminAccessToDefaultServiceAccount trên bảng điều khiển Phát hiện GuardDuty. Dành chút thời gian để phân tích chi tiết của Phát hiện, Hành động và Điều tra Phát hiện.\nXóa liên kết Vai trò của kẻ phạm tội bằng cách chạy lệnh sau.\n$ kubectl -n default delete rolebinding sa-default-admin Phát hiện này thông báo cho bạn biết rằng bảng điều khiển Cluster EKS của bạn đã được tiếp cận từ internet thông qua dịch vụ Load Balancer. Một bảng điều khiển được tiếp cận khiến giao diện quản lý của cụm của bạn có thể truy cập công khai từ internet và cho phép kẻ tấn công xấu khai thác bất kỳ khe hở xác thực và kiểm soát truy cập nào có thể tồn tại.\nĐể mô phỏng điều này, chúng ta cần cài đặt thành phần bảng điều khiển Kubernetes. Chúng tôi sẽ sử dụng phiên bản v2.7.0 của bảng điều khiển, đây là phiên bản tương thích mới nhất với Cluster EKS phiên bản v1.29 dựa trên ghi chú phát hành. Sau đó, chúng ta có thể tiếp cận bảng điều khiển từ Internet với loại Dịch vụ LoadBalancer, điều này sẽ tạo ra một Load Balancer Mạng (NLB) trong tài khoản AWS của bạn.\nChạy các lệnh sau để cài đặt thành phần bảng điều khiển Kubernetes. Điều này sẽ tạo ra một Namespace mới gọi là kubernetes-dashboard, và tất cả các tài nguyên sẽ được triển khai ở đó.\n$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml $ kubectl -n kubernetes-dashboard rollout status deployment/kubernetes-dashboard $ kubectl -n kubernetes-dashboard get pods NAME READY STATUS RESTARTS AGE dashboard-metrics-scraper-64bcc67c9c-tt9vl 1/1 Running 0 66s kubernetes-dashboard-5c8bd6b59-945zj 1/1 Running 0 66s Bây giờ, hãy sửa đổi Dịch vụ kubernetes-dashboard mới tạo thành loại LoadBalancer.\n$ kubectl -n kubernetes-dashboard patch svc kubernetes-dashboard -p=\u0026#39;{\u0026#34;spec\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;LoadBalancer\u0026#34;}}\u0026#39; Sau vài phút, NLB sẽ được tạo ra và hiển thị một địa chỉ có thể truy cập công khai trong Dịch vụ kubernetes-dashboard.\n$ kubectl -n kubernetes-dashboard get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE dashboard-metrics-scraper ClusterIP 172.20.8.169 \u0026lt;none\u0026gt; 8000/TCP 3m kubernetes-dashboard LoadBalancer 172.20.218.132 ad0fbc5914a2c4d1baa8dcc32101196b-2094501166.us-west-2.elb.amazonaws.com 443:32762/TCP 3m1s Nếu bạn quay lại bảng điều khiển Phát hiện GuardDuty, bạn sẽ thấy phát hiện Policy:Kubernetes/ExposedDashboard. Một lần nữa, hãy sử dụng một vài thời gian để phân tích chi tiết của Phát hiện, Hành động và Điều tra phát hiện.\nGỡ cài đặt các thành phần bảng điều khiển Kubernetes bằng cách chạy lệnh sau:\n$ kubectl delete -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml Trong lab này, bạn sẽ tạo một container với Security Context privileged, có quyền truy cập cấp root trong Namespace default của cụm EKS của bạn. Container này có thể truy cập vào một thư mục nhạy cảm từ máy chủ, được gắn kết và truy cập như một thư mục dữ liệu bên trong container của bạn.\nBài tập này sẽ tạo ra hai kết quả khác nhau, PrivilegeEscalation:Kubernetes/PrivilegedContainer chỉ ra rằng một container được khởi chạy với quyền Privileged, và Persistence:Kubernetes/ContainerWithSensitiveMount chỉ ra một đường dẫn máy chủ bên ngoài nhạy cảm được gắn kết bên trong container.\nĐể mô phỏng kết quả, bạn sẽ sử dụng một tập tin mô tả được cấu hình trước với một số tham số cụ thể đã được đặt trước, SecurityContext: privileged: true và cũng các tùy chọn volume và volumeMount, ánh xạ thư mục máy chủ /etc thành mount thư mục Pod /host-etc.\nmanifests/modules/security/Guardduty/mount/privileged-pod-example.yaml Áp dụng tập tin mô tả được hiển thị trên với lệnh sau:\n$ kubectl apply -f ~/environment/eks-workshop/modules/security/Guardduty/mount/privileged-pod-example.yaml Pod này chỉ chạy một lần, cho đến khi đạt được trạng thái Completed\nTrong vài phút tới, chúng ta sẽ thấy hai kết quả PrivilegeEscalation:Kubernetes/PrivilegedContainer và Persistence:Kubernetes/ContainerWithSensitiveMount trên bảng điều khiển Tìm thấy của GuardDuty.\nMột lần nữa, hãy dành một ít thời gian để phân tích chi tiết Tìm thấy, Hành động và Điều tra pháp lý.\nDọn dẹp Pod bằng cách chạy lệnh dưới đây:\n$ kubectl delete -f ~/environment/eks-workshop/modules/security/Guardduty/mount/privileged-pod-example.yaml "
},
{
	"uri": "//localhost:1313/vi/7-pod-security-standards/7.2-baseline-pss-profile/",
	"title": "Hạn chế quyền cho Pod trong Kubernetes",
	"tags": [],
	"description": "",
	"content": "Hạn chế quyền cho Pod trong Kubernetes Sẽ thế nào nếu chúng ta muốn hạn chế quyền mà một Pod có thể yêu cầu ? Chẳng hạn như quyền privileged mà chúng ta cung cấp cho Pod assets trong phần trước (có thể nguy hiểm, cho phép một kẻ tấn công truy cập vào tài nguyên của máy chủ bên ngoài của container).\nChính sách Baseline PSS là một chính sách hạn chế tối thiểu ngăn chặn việc tăng quyền biết trước. Hãy thêm nhãn vào assets Namespace để kích hoạt nó:\nmodules/security/pss-psa/baseline-namespace/namespace.yaml\rNamespace/assets Chạy Kustomize để áp dụng thay đổi này và thêm nhãn vào namespace assets:\n$ kubectl apply -k ~/environment/eks-workshop/modules/security/pss-psa/baseline-namespace Cảnh báo: các pod hiện có trong namespace \u0026#34;assets\u0026#34; vi phạm mức thực thi mới của PodSecurity \u0026#34;baseline:latest\u0026#34; Cảnh báo: assets-64c49f848b-gmrtt: privileged namespace/assets được cấu hình serviceaccount/assets không thay đổi configmap/assets không thay đổi service/assets không thay đổi deployment.apps/assets không thay đổi Bạn có thể thấy ở trên rằng chúng ta đã nhận được một cảnh báo rằng các Pod trong assets Deployment vi phạm Baseline PSS, được cung cấp bởi nhãn Namespace pod-security.kubernetes.io/warn. Bây giờ, hãy tái chế các Pods trong assets Deployment:\n$ kubectl -n assets delete pod --all Hãy kiểm tra xem các Pods có đang chạy không:\n$ kubectl -n assets get pod Không tìm thấy tài nguyên trong namespace assets. Như bạn có thể thấy, không có Pods nào đang chạy do nhãn Namespace pod-security.kubernetes.io/enforce, nhưng chúng ta không biết ngay lập tức lý do tại sao. Khi sử dụng độc lập, các chế độ PSA có các phản ứng khác nhau dẫn đến các trải nghiệm người dùng khác nhau. Chế độ thực thi ngăn chặn việc tạo Pods nếu các đặc tả Pod tương ứng vi phạm hồ sơ PSS được cấu hình. Tuy nhiên, trong chế độ này, các đối tượng Kubernetes không phải là Pod tạo ra Pods, chẳng hạn như Deployments, sẽ không bị ngăn chặn khỏi việc áp dụng vào cụm, ngay cả khi các đặc tả Pod trong đó vi phạm hồ sơ PSS được áp dụng. Trong trường hợp này, Deployment được áp dụng trong khi các Pods bị ngăn chặn khỏi việc áp dụng.\nChạy lệnh dưới đây để kiểm tra tình trạng điều kiện của tài nguyên Deployment:\n$ kubectl get deployment -n assets assets -o yaml | yq \u0026#39;.status\u0026#39; - lastTransitionTime: \u0026#34;2022-11-24T04:49:56Z\u0026#34; lastUpdateTime: \u0026#34;2022-11-24T05:10:41Z\u0026#34; message: ReplicaSet \u0026#34;assets-7445d46757\u0026#34; has successfully progressed. reason: NewReplicaSetAvailable status: \u0026#34;True\u0026#34; type: Progressing - lastTransitionTime: \u0026#34;2022-11-24T05:10:49Z\u0026#34; lastUpdateTime: \u0026#34;2022-11-24T05:10:49Z\u0026#34; message: \u0026#39;pods \u0026#34;assets-67d5fc995b-8r9t2\u0026#34; is forbidden: violates PodSecurity \u0026#34;baseline:latest\u0026#34;: privileged (container \u0026#34;assets\u0026#34; must not set securityContext.privileged=true)\u0026#39; reason: FailedCreate status: \u0026#34;True\u0026#34; type: ReplicaFailure - lastTransitionTime: \u0026#34;2022-11-24T05:10:56Z\u0026#34; lastUpdateTime: \u0026#34;2022-11-24T05:10:56Z\u0026#34; message: Deployment does not have minimum availability. reason: MinimumReplicasUnavailable status: \u0026#34;False\u0026#34; type: Available Trong một số tình huống, không có biểu hiện ngay lập tức rằng đối tượng Deployment được áp dụng thành công phản ánh việc tạo Pods thất bại. Các đặc tả Pod vi phạm không tạo ra Pods. Kiểm tra tài nguyên Deployment với kubectl get deploy -o yaml ... sẽ tiết lộ tin nhắn từ các Pod(s) thất bại trong .status.conditions như đã thấy trong quá trình kiểm tra của chúng tôi ở trên.\nTrong cả hai chế độ PSA kiểm tra và cảnh báo, các hạn chế Pod không ngăn chặn việc tạo và khởi chạy các Pods vi phạm. Tuy nhiên, trong các chế độ này, các chú thích kiểm tra của audit trên các sự kiện nhật ký kiểm tra API server và cảnh báo đối với các khách hàng API server (ví dụ: kubectl) được kích hoạt. Điều này xảy ra khi Pods, cũng như các đối tượng tạo ra Pods, chứa đặc tả Pod vi phạm PSS.\nBây giờ, hãy sửa tài nguyên Deployment assets để nó chạy bằng cách loại bỏ cờ privileged:\n$ kubectl apply -k ~/environment/eks-workshop/modules/security/pss-psa/baseline-workload namespace/assets không thay đổi serviceaccount/assets không thay đổi configmap/assets không thay đổi service/assets không thay đổi deployment.apps/assets được cấu hình Lần này chúng tôi không nhận được cảnh báo nên hãy kiểm tra xem các Pods có đang chạy không, và chúng tôi có thể xác nhận rằng nó không chạy dưới quyền root nữa:\n$ kubectl -n assets get pod NAME READY STATUS RESTARTS AGE assets-864479dc44-d9p79 1/1 Running 0 15s $ kubectl -n assets exec $(kubectl -n assets get pods -o name) -- whoami nginx Vì chúng tôi đã khắc phục lỗi Pod chạy trong chế độ privileged nên bây giờ nó được phép chạy dưới hồ sơ Baseline.\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.2-managing-secrets-with-aws-secrets-manager/",
	"title": "Quản lý khoá bí mật bằng AWS Secrets Manager",
	"tags": [],
	"description": "",
	"content": "Quản lý khoá bí mật bằng AWS Secrets Manager Chuẩn bị môi trường cho phần này: $ prepare-environment security/secrets-manager Điều này sẽ thực hiện những thay đổi sau đây trong môi trường thí nghiệm của bạn:\nCài đặt các phần mở rộng Kubernetes sau đây trong Cụm EKS của bạn:\nKubernetes Secrets Store CSI Driver AWS Secrets and Configuration Provider External Secrets Operator Bạn có thể xem Terraform áp dụng những thay đổi này tại đây.\nAWS Secrets Manager cho phép bạn dễ dàng xoay vòng, quản lý và lấy dữ liệu nhạy cảm như thông tin đăng nhập, khóa API, chứng chỉ, và những thông tin khác. Bạn có thể sử dụng AWS Secrets and Configuration Provider (ASCP) cho Kubernetes Secrets Store CSI Driver để gắn kết các bí mật được lưu trữ trong Secrets Manager dưới dạng khối lượng trong các Pod Kubernetes.\nVới ASCP, bạn có thể lưu trữ và quản lý các thông tin bí mật của mình trong Secrets Manager và sau đó lấy chúng thông qua các khối công việc đang chạy trên Amazon EKS. Bạn có thể sử dụng vai trò và chính sách IAM để giới hạn quyền truy cập vào các bí mật của bạn cho các Pod Kubernetes cụ thể trong một cụm. ASCP lấy danh tính Pod và trao đổi danh tính đó để đổi lấy một vai trò IAM. ASCP giả định vai trò IAM của Pod, sau đó nó có thể lấy các bí mật từ Secrets Manager mà được ủy quyền cho vai trò đó.\nMột cách khác để tích hợp AWS Secrets Manager với Kubernetes Secrets là thông qua External Secrets. External Secrets là một toán tử có thể tích hợp và đồng bộ hóa các bí mật từ AWS Secrets Manager đọc thông tin từ nó và tự động tiêm các giá trị vào một Kubernetes Secret với một dạng trừu tượng hóa lưu trữ và quản lý vòng đời của các bí mật cho bạn.\nNếu bạn sử dụng xoay vòng tự động của Secrets Manager cho các bí mật của bạn, bạn có thể phụ thuộc vào khoảng thời gian làm mới của External Secrets hoặc sử dụng tính năng hòa giải xoay vòng của Secrets Store CSI Driver để đảm bảo bạn đang lấy khoá bí mật mới nhất từ Secrets Manager, tùy thuộc vào công cụ bạn chọn để quản lý các bí mật bên trong Cụm Amazon EKS của bạn.\nTrong phần tiếp theo của thí nghiệm này, chúng ta sẽ tạo một vài tình huống mẫu về việc sử dụng các bí mật từ AWS Secrets Manager và External Secrets.\n"
},
{
	"uri": "//localhost:1313/vi/4-amazon-eks-pod-identity/4.2-using-amazon-dynamodb/",
	"title": "Sử dụng Amazon DynamoDB",
	"tags": [],
	"description": "",
	"content": "Sử dụng Amazon DynamoDB Quy trình đầu tiên trong quá trình này là cấu hình lại dịch vụ carts để sử dụng một bảng DynamoDB đã được tạo trước cho chúng ta. Ứng dụng tải hầu hết cấu hình từ một ConfigMap, hãy xem nó:\n$ kubectl -n carts get -o yaml cm carts apiVersion: v1 data: AWS_ACCESS_KEY_ID: key AWS_SECRET_ACCESS_KEY: secret CARTS_DYNAMODB_CREATETABLE: true CARTS_DYNAMODB_ENDPOINT: http://carts-dynamodb:8000 CARTS_DYNAMODB_TABLENAME: Items kind: ConfigMap metadata: name: carts namespace: carts Ngoài ra, kiểm tra tình trạng hiện tại của ứng dụng bằng cách sử dụng trình duyệt. Một dịch vụ kiểu LoadBalancer có tên ui-nlb được cung cấp trong không gian tên ui, từ đó có thể truy cập giao diện người dùng của ứng dụng.\n$ kubectl -n ui get service ui-nlb -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[*].hostname}{\u0026#34;\\n\u0026#34;}\u0026#39; k8s-ui-uinlb-647e781087-6717c5049aa96bd9.elb.us-west-2.amazonaws.com Sử dụng URL được tạo ra từ lệnh trên để mở giao diện người dùng trong trình duyệt của bạn. Nó nên mở trang chủ cửa hàng như được hiển thị dưới đây.\nBây giờ, kustomization sau đây ghi đè lên ConfigMap, loại bỏ cấu hình điểm cuối DynamoDB, làm cho SDK mặc định sử dụng dịch vụ DynamoDB thực sự thay vì Pod kiểm thử của chúng tôi. Chúng tôi cũng đã cung cấp tên của bảng DynamoDB đã được tạo cho chúng tôi, được lấy từ biến môi trường CARTS_DYNAMODB_TABLENAME.\nmodules/security/eks-pod-identity/dynamo/kustomization.yaml\rConfigMap/carts Hãy kiểm tra giá trị của CARTS_DYNAMODB_TABLENAME sau đó chạy Kustomize để sử dụng dịch vụ DynamoDB thực sự:\n$ echo $CARTS_DYNAMODB_TABLENAME eks-workshop-carts $ kubectl kustomize ~/environment/eks-workshop/modules/security/eks-pod-identity/dynamo \\ | envsubst | kubectl apply -f- Điều này sẽ ghi đè lên ConfigMap của chúng tôi với các giá trị mới:\n$ kubectl -n carts get cm carts -o yaml apiVersion: v1 data: CARTS_DYNAMODB_TABLENAME: eks-workshop-carts kind: ConfigMap metadata: labels: app: carts name: carts namespace: carts Chúng ta sẽ cần khởi động lại tất cả các Pod của ứng dụng carts để lấy nội dung ConfigMap mới của chúng ta.\n$ kubectl -n carts rollout restart deployment/carts deployment.apps/carts restarted $ kubectl -n carts rollout status deployment/carts Vậy bây giờ ứng dụng của chúng ta nên đang sử dụng DynamoDB phải không? Hãy thử tải nó lên trong trình duyệt bằng URL được xuất ra trong lệnh trước đó và điều hướng đến giỏ hàng.\n$ kubectl -n ui get service ui-nlb -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[*].hostname}{\u0026#34;\\n\u0026#34;}\u0026#39; k8s-ui-uinlb-647e781087-6717c5049aa96bd9.elb.us-west-2.amazonaws.com Trang giỏ hàng không thể truy cập được! Điều gì đã xảy ra không ổn?\n"
},
{
	"uri": "//localhost:1313/vi/3-iam-roles-for-service-accounts/3.2-using-dynamodb/",
	"title": "Sử dụng DynamoDB",
	"tags": [],
	"description": "",
	"content": "Sử dụng DynamoDB Bước đầu tiên trong quy trình này là cấu hình lại dịch vụ giỏ hàng để sử dụng một bảng DynamoDB đã được tạo trước đó cho chúng ta. Ứng dụng tải hầu hết các cấu hình từ một ConfigMap, hãy xem nó:\nkubectl -n carts get -o yaml cm carts apiVersion: v1 data: AWS_ACCESS_KEY_ID: key AWS_SECRET_ACCESS_KEY: secret CARTS_DYNAMODB_CREATETABLE: true CARTS_DYNAMODB_ENDPOINT: http://carts-dynamodb:8000 CARTS_DYNAMODB_TABLENAME: Items kind: ConfigMap metadata: name: carts namespace: carts Kustomization sau đây ghi đè lên ConfigMap, loại bỏ cấu hình đầu cuối DynamoDB endpoint để SDK mặc định sử dụng dịch vụ DynamoDB thực tế thay vì Pod kiểm tra của chúng tôi. Chúng tôi cũng đã cung cấp tên bảng DynamoDB đã được tạo sẵn cho chúng ta, được rút ra từ biến môi trường CARTS_DYNAMODB_TABLENAME.\nKustomize Patch ConfigMap/carts Diff\napiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization resources: - ../../../../base-application/carts configMapGenerator: - name: carts namespace: carts env: config.properties behavior: replace options: disableNameSuffixHash: true Hãy kiểm tra giá trị của CARTS_DYNAMODB_TABLENAME sau đó chạy Kustomize để sử dụng dịch vụ DynamoDB thực tế:\necho $CARTS_DYNAMODB_TABLENAME eks-workshop-carts kubectl kustomize ~/environment/eks-workshop/modules/security/irsa/dynamo \\ | envsubst | kubectl apply -f- Điều này sẽ ghi đè lên ConfigMap của chúng tôi với các giá trị mới:\nkubectl get -n carts cm carts -o yaml apiVersion: v1 data: CARTS_DYNAMODB_TABLENAME: eks-workshop-carts kind: ConfigMap metadata: labels: app: carts name: carts namespace: carts Bây giờ chúng ta cần khởi động lại tất cả các Pod carts để lấy nội dung ConfigMap mới của chúng tôi:\nkubectl rollout restart -n carts deployment/carts kubectl rollout status -n carts deployment/carts Hãy thử truy cập ứng dụng của chúng ta bằng trình duyệt. Một dịch vụ kiểu LoadBalancer có tên ui-nlb được cung cấp trong không gian tên ui từ đó có thể truy cập giao diện người dùng của ứng dụng.\nkubectl get service -n ui ui-nlb -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[*].hostname}{\u0026#34;\\n\u0026#34;}\u0026#39; k8s-ui-uinlb-647e781087-6717c5049aa96bd9.elb.us-west-2.amazonaws.com Vậy bây giờ ứng dụng của chúng ta phải đang sử dụng DynamoDB đúng không? Hãy mở nó trong trình duyệt bằng cách sử dụng đầu ra của lệnh trên và điều hướng đến giỏ hàng:\nTrang giỏ hàng không thể truy cập! Đã xảy ra vấn đề gì?\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.2-authentication/",
	"title": "Xác thực (Authentication)",
	"tags": [],
	"description": "",
	"content": "Tài khoản (Accounts) Các người dùng khác nhau có thể truy cập vào bảo mật của cụm được quản lý bởi các ứng dụng tự quản lý bên trong cụm mà họ truy cập. Vậy, chúng ta còn lại 2 loại người dùng:\nNgười: như Quản trị viên và Nhà phát triển Robot: như các quy trình/dịch vụ hoặc ứng dụng đòi hỏi truy cập vào cụm. Tất cả quản lý truy cập người dùng đều được thực hiện bởi apiserver và tất cả các yêu cầu đi qua apiserver. Cơ chế Xác thực (Authentication Mechanisms) Có các cơ chế xác thực khác nhau có thể được cấu hình.\nCơ chế Xác thực cơ bản Cấu hình kube-apiserver Nếu bạn thiết lập thông qua kubeadm thì cập nhật tệp mẫu kube-apiserver.yaml với tùy chọn. Xác thực Người dùng (Authenticate User) Để xác thực bằng các thông tin đăng nhập cơ bản khi truy cập vào máy chủ API, chỉ định tên người dùng và mật khẩu trong một lệnh curl. $ curl -v -k http://master-node-ip:6443/api/v1/pods -u \u0026#34;user1:password123\u0026#34; Chúng ta có thể có thêm cột trong tập tin user-details.csv để gán người dùng vào các nhóm cụ thể.\nK8s Reference Docs https://kubernetes.io/docs/reference/access-authn-authz/authentication/ "
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.3-securing-secrets-using-sealed-secrets/",
	"title": "Bảo vệ khoá bí mật bằng Seal Secrets",
	"tags": [],
	"description": "",
	"content": "Bảo vệ khoá bí mật bằng Seal Secrets Dự án Sealed Secrets không liên quan đến Dịch vụ AWS mà là một công cụ mã nguồn mở từ bên thứ ba của Btinami Labs\nChuẩn bị môi trường của bạn cho phần này:\n$ prepare-environment security/sealed-secrets Sealed Secrets cung cấp một cơ chế để mã hóa một đối tượng Secret để nó an toàn để lưu trữ - thậm chí là vào một kho lưu trữ công cộng. Một SealedSecret chỉ có thể được giải mã bởi bộ điều khiển đang chạy trong cụm Kubernetes và không ai khác có thể lấy được Secret gốc từ một SealedSecret.\nTrong chương này, bạn sẽ sử dụng SealedSecrets để mã hóa các tài liệu YAML liên quan đến Secrets của Kubernetes cũng như có thể triển khai các Secrets đã được mã hóa này lên các cụm EKS của bạn bằng các luồng làm việc thông thường với các công cụ như kubectl.\n"
},
{
	"uri": "//localhost:1313/vi/8-policy-management-with-kyverno/8.3-restricting-image-registries/",
	"title": "Creating a Simple Policy",
	"tags": [],
	"description": "",
	"content": "Sử dụng hình ảnh container từ các nguồn không rõ trên các Cụm EKS của bạn, có thể không được quét để phát hiện Các Lỗ Hổng và Công Bố (CVE), đại diện cho một yếu tố nguy cơ đối với tổng thể an ninh của môi trường của bạn. Khi lựa chọn nguồn hình ảnh container, bạn cần đảm bảo rằng chúng có nguồn gốc từ Các Đăng Ký Đáng Tin Cậy, nhằm giảm thiểu nguy cơ tiếp xúc và khai thác các lỗ hổng. Một số tổ chức lớn cũng có Hướng Dẫn Về An Ninh giới hạn việc sử dụng hình ảnh container từ hệ thống đăng ký hình ảnh riêng được lưu trữ của họ.\nTrong phần này, bạn sẽ thấy làm thế nào Kyverno có thể giúp bạn chạy các tải công việc container an toàn bằng cách hạn chế Các Đăng Ký Hình Ảnh có thể được sử dụng trong cụm của bạn.\nNhư đã thấy trong các phòng thí nghiệm trước đó, bạn có thể chạy Pods với các hình ảnh từ bất kỳ đăng ký nào có sẵn, vì vậy hãy chạy một Pod mẫu bằng cách sử dụng đăng ký mặc định trỏ đến docker.io.\n$ kubectl run nginx --image=nginx NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 47s $ kubectl describe pod nginx | grep Image Image: nginx Image ID: docker.io/library/nginx@sha256:4c0fdaa8b6341bfdeca5f18f7837462c80cff90527ee35ef185571e1c327beac Trong trường hợp này, chỉ là một hình ảnh cơ sở nginx được kéo từ Đăng Ký Công Cộng. Một kẻ tấn công có thể kéo bất kỳ hình ảnh có lỗ hổng nào và chạy trên Cụm EKS, khai thác tài nguyên được cấp trong cụm.\nTiếp theo, như một thực hành tốt nhất, bạn sẽ xác định một chính sách sẽ hạn chế việc sử dụng bất kỳ Đăng Ký Hình Ảnh không được ủy quyền nào và chỉ phụ thuộc vào Các Đăng Ký Đáng Tin Cậy được chỉ định.\nTrong phòng thí nghiệm này, bạn sẽ sử dụng Amazon ECR Public Gallery làm Đăng Ký Đáng Tin Cậy, chặn bất kỳ container nào sử dụng Hình Ảnh được lưu trữ trong các đăng ký khác để chạy. Dưới đây là một chính sách Kyverno mẫu để hạn chế việc kéo hình ảnh cho trường hợp sử dụng này.\nmanifests/modules/security/kyverno/images/restrict-registries.yaml Phần trên không hạn chế việc sử dụng InitContainers hoặc Ephemeral Containers đến kho lưu trữ được tham chiếu.\nÁp dụng chính sách trên bằng lệnh dưới đây.\n$ kubectl apply -f ~/environment/eks-workshop/modules/security/kyverno/images/restrict-registries.yaml clusterpolicy.kyverno.io/restrict-image-registries created Hãy thử chạy một Pod mẫu khác bằng cách sử dụng hình ảnh mặc định từ Đăng Ký Công Cộng.\n$ kubectl run nginx-public --image=nginx Error from server: admission webhook \u0026#34;validate.kyverno.svc-fail\u0026#34; denied the request: resource Pod/default/nginx-public was blocked due to the following policies restrict-image-registries: validate-registries: \u0026#39;validation error: Unknown Image registry. rule validate-registries failed at path /spec/containers/0/image/\u0026#39; Pod không thể chạy và hiển thị một đầu ra cho biết việc Tạo Pod đã bị chặn do Chính Sách Kyverno đã được tạo trước đó của chúng tôi.\nBây giờ hãy thử chạy một Pod mẫu bằng cách sử dụng Hình Ảnh nginx được lưu trữ trong Đăng Ký Đáng Tin Cậy, đã được xác định trước trong Chính Sách (public.ecr.aws).\n$ kubectl run nginx-ecr --image=public.ecr.aws/nginx/nginx pod/nginx-public created Pod đã được tạo thành công!\nBạn đã thấy cách bạn có thể chặn Hình Ảnh từ các đăng ký công cộng để chạy trên Cụm EKS của bạn và chỉ hạn chế Các Kho Lưu Trữ Hình Ảnh được phép. Một người có thể tiến xa hơn, và chỉ cho phép các kho lưu trữ riêng tư làm Thực Hành Bảo Mật Tốt Nhất.\nĐừng gỡ bỏ các Pods đang chạy được tạo trong nhiệm vụ này vì chúng ta sẽ sử dụng chúng cho phòng thí nghiệm tiếp theo.\n"
},
{
	"uri": "//localhost:1313/vi/6-amazon-guardduty-for-eks/6.3-eks-runtime-monitoring/",
	"title": "EKS Runtime Monitoring",
	"tags": [],
	"description": "",
	"content": "Giám sát EKS Runtime Giám sát runtime (EKS Runtime Monitoring) cung cấp khả năng phát hiện mối đe dọa trong runtime cho các nút và container Amazon EKS. Nó sử dụng agent bảo mật GuardDuty (phần mở rộng EKS) để cung cấp khả năng hiển thị runtime trong các công việc EKS cụ thể, ví dụ như truy cập tệp, thực thi quy trình, tăng quyền và kết nối mạng nhận dạng các container cụ thể có thể bị xâm nhập.\nKhi bạn kích hoạt Giám sát Thời Gian Chạy EKS, GuardDuty có thể bắt đầu giám sát các sự kiện thời gian chạy trong cụm EKS của bạn. Nếu cụm EKS của bạn không có agent bảo mật được triển khai tự động thông qua GuardDuty hoặc thủ công, GuardDuty sẽ không thể nhận các sự kiện thời gian chạy của các cụm EKS của bạn, có nghĩa là agent phải được triển khai trên các nút EKS trong các cụm EKS của bạn. Bạn có thể chọn GuardDuty để quản lý agent bảo mật tự động hoặc bạn có thể quản lý việc triển khai và cập nhật agent bảo mật thủ công.\nTrong bài thực hành này, chúng ta sẽ tạo ra một số phát hiện thời gian chạy EKS trong cụm Amazon EKS của bạn, được liệt kê dưới đây.\nExecution:Runtime/NewBinaryExecuted CryptoCurrency:Runtime/BitcoinTool.B!DNS Execution:Runtime/NewLibraryLoaded DefenseEvasion:Runtime/FilelessExecution Dấu hiệu này cho thấy một container đã cố gắng thực hiện việc đào tiền điện tử bên trong một Pod.\nĐể mô phỏng dấu hiệu này, chúng ta sẽ chạy một Pod hình ảnh ubuntu trong không gian tên default và từ đó chạy một vài lệnh để mô phỏng việc tải xuống một quy trình đào tiền điện tử.\nChạy lệnh dưới đây để bắt đầu Pod:\n$ kubectl run crypto -n other --image ubuntu --restart=Never --command -- sleep infinity $ kubectl wait --for=condition=ready pod crypto -n other Tiếp theo, chúng ta có thể sử dụng kubectl exec để chạy một loạt các lệnh bên trong Pod. Đầu tiên, hãy cài đặt tiện ích curl:\n$ kubectl exec crypto -n other -- bash -c \u0026#39;apt update \u0026amp;\u0026amp; apt install -y curl\u0026#39; Tiếp theo, hãy tải xuống quy trình đào tiền điện tử nhưng ghi đầu ra vào /dev/null:\n$ kubectl exec crypto -n other -- bash -c \u0026#39;curl -s -o /dev/null http://us-east.equihash-hub.miningpoolhub.com:12026 || true \u0026amp;\u0026amp; echo \u0026#34;Done!\u0026#34;\u0026#39; Những lệnh này sẽ kích hoạt ba phát hiện khác nhau trên bảng điều khiển Phát hiện GuardDuty.\nPhát hiện đầu tiên là Execution:Runtime/NewBinaryExecuted liên quan đến việc cài đặt gói curl thông qua công cụ APT.\nHãy xem xét kỹ các chi tiết của phát hiện này, bởi vì chúng liên quan đến giám sát thời gian chạy của GuardDuty, hiển thị thông tin cụ thể về thời gian chạy, ngữ cảnh và quy trình.\nPhát hiện thứ hai và ba liên quan đến các phát hiện CryptoCurrency:Runtime/BitcoinTool.B!DNS. Lưu ý một lần nữa rằng các chi tiết phát hiện mang lại thông tin khác nhau, lần này hiển thị hành động DNS_REQUEST, và Bằng chứng tình báo Mối đe dọa.\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.2-managing-secrets-with-aws-secrets-manager/5.2.3-mounting-aws-secrets-manager/",
	"title": "Gắn secret trong AWS Secrets Manager lên Pod Kubernetes",
	"tags": [],
	"description": "",
	"content": "Gắn secret trong AWS Secrets Manager lên Pod Kubernetes Bây giờ chúng ta đã lưu một Secret trong AWS Secrets Manager và đồng bộ hóa với một Secret trong Kubernetes, hãy gắn nó vào trong Pod. Đầu tiên, chúng ta nên xem qua catalog Deployment và các Secrets hiện có trong namespace catalog.\nDeployment catalog truy cập các thông tin xác thực cơ sở dữ liệu sau từ secret catalog-db thông qua biến môi trường:\nDB_USER DB_PASSWORD $ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.containers[] | .env\u0026#39; - name: DB_USER valueFrom: secretKeyRef: key: username name: catalog-db - name: DB_PASSWORD valueFrom: secretKeyRef: key: password name: catalog-db Chú ý rằng Deployment catalog không có bất kỳ volumes hoặc volumeMounts nào ngoại trừ một emptyDir được gắn vào /tmp.\n$ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.volumes\u0026#39; - emptyDir: medium: Memory name: tmp-volume $ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.containers[] | .volumeMounts\u0026#39; - mountPath: /tmp name: tmp-volume Hãy áp dụng các thay đổi trong Deployment catalog để sử dụng secret được lưu trong AWS Secrets Manager làm nguồn của thông tin xác thực.\nmodules/security/secrets-manager/mounting-secrets/kustomization.yaml\rDeployment/catalog Ở đây, chúng ta sẽ gắn secret trong AWS Secrets Manager bằng cách sử dụng CSI driver với SecretProviderClass chúng ta đã xác thực trước đó trên mountPath /etc/catalog-secret bên trong Pod. Khi điều này xảy ra, AWS Secrets Manager sẽ đồng bộ nội dung của secret đã lưu với Amazon EKS và tạo một Secret trong Kubernetes với cùng nội dung có thể được tiêu thụ như biến môi trường trong Pod.\n$ kubectl kustomize ~/environment/eks-workshop/modules/security/secrets-manager/mounting-secrets/ \\ | envsubst | kubectl apply -f- $ kubectl rollout status -n catalog deployment/catalog --timeout=120s Hãy xác thực các thay đổi đã được thực hiện trong Namespace catalog.\nTrong Deployment, chúng ta sẽ có thể kiểm tra rằng nó có một volume mới và volumeMount tương ứng trỏ đến CSI Secret Store Driver, và được gắn vào đường dẫn /etc/catalog-secrets.\n$ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.volumes\u0026#39; - csi: driver: secrets-store.csi.k8s.io readOnly: true volumeAttributes: secretProviderClass: catalog-spc name: catalog-secret - emptyDir: medium: Memory name: tmp-volume $ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.containers[] | .volumeMounts\u0026#39; - mountPath: /etc/catalog-secret name: catalog-secret readOnly: true - mountPath: /tmp name: tmp-volume Các Secrets được gắn kết là một cách tốt để có thông tin nhạy cảm có sẵn dưới dạng một tệp trong hệ thống tệp của một hoặc nhiều container trong Pod. Một số lợi ích là không tiết lộ giá trị của secret như biến môi trường và khi một volume chứa dữ liệu từ một Secret và khi Secret đó được cập nhật, Kubernetes sẽ theo dõi và cập nhật dữ liệu trong volume.\nBạn có thể xem nội dung của Secret đã được gắn kết bên trong Pod của bạn.\n$ kubectl -n catalog exec deployment/catalog -- ls /etc/catalog-secret/ eks-workshop-catalog-secret password username $ kubectl -n catalog exec deployment/catalog -- cat /etc/catalog-secret/${SECRET_NAME} {\u0026#34;username\u0026#34;:\u0026#34;catalog_user\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;default_password\u0026#34;} $ kubectl -n catalog exec deployment/catalog -- cat /etc/catalog-secret/username catalog_user $ kubectl -n catalog exec deployment/catalog -- cat /etc/catalog-secret/password default_password Có 3 tệp trong mountPath /etc/catalog-secret.\neks-workshop-catalog-secret: Giá trị của secret dưới dạng JSON. password: Giá trị đã được lọc và định dạng theo jmesPath của mật khẩu. username: Giá trị đã được lọc và định dạng theo jmesPath của tên người dùng. Ngoài ra, các biến môi trường hiện đang được tiêu thụ từ Secret mới, catalog-secret, không tồn tại trước đó, và nó đã được tạo bởi SecretProviderClass thông qua CSI Secret Store driver.\n$ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.containers[] | .env\u0026#39; - name: DB_USER valueFrom: secretKeyRef: key: username name: catalog-secret - name: DB_PASSWORD valueFrom: secretKeyRef: key: password name: catalog-secret $ kubectl -n catalog get secrets NAME TYPE DATA AGE catalog-db Opaque 2 15h catalog-secret Opaque 2 43s Chúng ta có thể xác nhận điều này bằng cách kiểm tra các biến môi trường trong Pod đang chạy:\n$ kubectl -n catalog exec -ti deployment/catalog -- env | grep DB_ Bây giờ chúng ta đã có một Kubernetes Secret tích hợp hoàn toàn với AWS Secrets Manager có thể tận dụng quá trình secret rotation. Đây là một thực hành tốt cho Quản lý Secrets. Mỗi khi một secret được rotate hoặc cập nhật trên AWS Secrets Manager, chúng ta có thể triển khai một phiên bản mới của Deployment để CSI Secret Store driver có thể đồng bộ nội dung của Kubernetes Secrets với giá trị đã được xoay.\n"
},
{
	"uri": "//localhost:1313/vi/3-iam-roles-for-service-accounts/3.3-understanding-pod-iam/",
	"title": "Hiểu về Pod IAM",
	"tags": [],
	"description": "",
	"content": "Điểm đầu tiên để tìm vấn đề là trong log của dịch vụ carts:\n$ kubectl logs -n carts deployment/carts Điều này sẽ trả về nhiều log, vì vậy hãy lọc để có cái nhìn ngắn gọn về vấn đề:\n$ kubectl -n carts logs deployment/carts \\ | grep DynamoDbException 2024-01-09T18:54:10.818Z ERROR 1 --- ${sys:LOGGED_APPLICATION_NAME}[nio-8080-exec-1] o.a.c.c.C.[.[.[.[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: software.amazon.awssdk.services.dynamodb.model.DynamoDbException: User: arn:aws:sts::123456789012:assumed-role/eksctl-eks-workshop-nodegroup-defa-NodeInstanceRole-vniVa7QtGHXO/i-075976199b049a358 is not authorized to perform: dynamodb:Query on resource: arn:aws:dynamodb:us-west-2:123456789012:table/eks-workshop-carts/index/idx_global_customerId because no identity-based policy allows the dynamodb:Query action (Service: DynamoDb, Status Code: 400, Request ID: QEQBV8R44MI1DSRQFGIAAAOS8FVV4KQNSO5AEMVJF66Q9ASUAAJG)] with root cause software.amazon.awssdk.services.dynamodb.model.DynamoDbException: User: arn:aws:sts::123456789012:assumed-role/eksctl-eks-workshop-nodegroup-defa-NodeInstanceRole-vniVa7QtGHXO/i-075976199b049a358 is not authorized to perform: dynamodb:Query on resource: arn:aws:dynamodb:us-west-2:123456789012:table/eks-workshop-carts/index/idx_global_customerId because no identity-based policy allows the dynamodb:Query action (Service: DynamoDb, Status Code: 400, Request ID: QEQBV8R44MI1DSRQFGIAAAOS8FVV4KQNSO5AEMVJF66Q9ASUAAJG) Ứng dụng của chúng ta đang tạo ra một AccessDeniedException, cho thấy vai trò IAM mà Pod của chúng ta đang sử dụng để truy cập DynamoDB không có các quyền cần thiết. Điều này xảy ra vì Pod của chúng ta mặc định đang sử dụng vai trò IAM được gán cho nút làm việc EC2 mà nó đang chạy, không có IAM Policy cho phép truy cập vào DynamoDB.\nMột cách chúng ta có thể giải quyết vấn đề này là mở rộng quyền IAM của các nút làm việc EC2 của chúng ta, nhưng điều này sẽ cho phép bất kỳ Pod nào chạy trên chúng truy cập vào bảng DynamoDB của chúng ta, điều này không phải là một thực hành tốt và cũng không an toàn. Thay vào đó, chúng ta sẽ sử dụng IAM Roles for Service Accounts (IRSA) để cụ thể cho phép các Pod trong dịch vụ carts truy cập.\n"
},
{
	"uri": "//localhost:1313/vi/4-amazon-eks-pod-identity/4.3-understanding-pod-iam/",
	"title": "Hiểu về Pod IAM",
	"tags": [],
	"description": "",
	"content": "Hiểu về Pod IAM Điểm đầu tiên để tìm vấn đề là logs của dịch vụ carts:\n$ kubectl -n carts logs deployment/carts ... đoạn output đã bị lược bỏ Điều này sẽ trả về nhiều logs, vì vậy hãy lọc để có cái nhìn tổng quan về vấn đề:\n$ kubectl -n carts logs deployment/carts | grep -i Exception 2024-02-12T20:20:47.547Z ERROR 1 --- [nio-8080-exec-7] o.a.c.c.C.[.[.[.[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: com.amazonaws.services.dynamodbv2.model.AmazonDynamoDBException: User: arn:aws:sts::123456789000:assumed-role/eksctl-eks-workshop-nodegroup-defa-NodeInstanceRole-Q1p0w2o9e3i8/i-0p1qaz2wsx3edc4rfv is not authorized to perform: dynamodb:Query on resource: arn:aws:dynamodb:us-west-2:123456789000:table/Items/index/idx_global_customerId because no identity-based policy allows the dynamodb:Query action (Service: AmazonDynamoDBv2; Status Code: 400; Error Code: AccessDeniedException; Request ID: MA54K0UDUOCLJ96UP6PT76VTBBVV4KQNSO5AEMVJF66Q9ASUAAJG; Proxy: null)] with root cause com.amazonaws.services.dynamodbv2.model.AmazonDynamoDBException: User: arn:aws:sts::123456789000:assumed-role/eksctl-eks-workshop-nodegroup-defa-NodeInstanceRole-Q1p0w2o9e3i8/i-0p1qaz2wsx3edc4rfv is not authorized to perform: dynamodb:Query on resource: arn:aws:dynamodb:us-west-2:123456789000:table/Items/index/idx_global_customerId because no identity-based policy allows the dynamodb:Query action (Service: AmazonDynamoDBv2; Status Code: 400; Error Code: AccessDeniedException; Request ID: MA54K0UDUOCLJ96UP6PT76VTBBVV4KQNSO5AEMVJF66Q9ASUAAJG; Proxy: null) Ứng dụng đang tạo ra một AccessDeniedException cho thấy rằng IAM Role mà Pod của chúng ta đang sử dụng để truy cập DynamoDB không có các quyền cần thiết. Điều này xảy ra vì mặc định, nếu không có IAM Roles hoặc Policies nào được liên kết với Pod của chúng ta, nó sẽ sử dụng IAM Role liên kết với Instance Profile được gán cho instance EC2 đang chạy, trong trường hợp này Role này không có một IAM Policy nào cho phép truy cập vào DynamoDB.\nMột cách chúng ta có thể giải quyết vấn đề này là mở rộng IAM permissions của Instance Profile của EC2, nhưng điều này sẽ cho phép bất kỳ Pod nào chạy trên chúng có thể truy cập vào bảng DynamoDB của chúng ta, điều này không an toàn và không phải là một thực hành tốt cho việc cấp quyền ít nhất cần thiết. Thay vào đó, chúng ta sẽ sử dụng EKS Pod Identity để cho phép truy cập cụ thể cần thiết bởi ứng dụng carts tại mức Pod.\n"
},
{
	"uri": "//localhost:1313/vi/3-iam-roles-for-service-accounts/",
	"title": "IAM Roles for Service Accounts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.3-securing-secrets-using-sealed-secrets/5.3.3-sealing-your-secrets/",
	"title": "Niêm phong khoá bí mật",
	"tags": [],
	"description": "",
	"content": "Niêm phong khoá bí mật Khám phá Pod trong danh mục Việc triển khai catalog trong Namespace catalog truy cập các giá trị cơ sở dữ liệu sau từ secret catalog-db thông qua biến môi trường:\nDB_USER DB_PASSWORD $ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.containers[] | .env\u0026#39; - name: DB_USER valueFrom: secretKeyRef: key: username name: catalog-db - name: DB_PASSWORD valueFrom: secretKeyRef: key: password name: catalog-db - name: DB_NAME valueFrom: configMapKeyRef: key: name name: catalog - name: DB_READ_ENDPOINT valueFrom: secretKeyRef: key: endpoint name: catalog-db - name: DB_ENDPOINT valueFrom: secretKeyRef: key: endpoint name: catalog-db Khi khám phá Secret catalog-db, chúng ta thấy rằng nó chỉ được mã hóa bằng base64, có thể dễ dàng giải mã như sau, gây khó khăn cho các biểu mẫu secrets khi tham gia vào quy trình làm việc GitOps.\nmanifests/base-application/catalog/secrets.yaml $ kubectl -n catalog get secrets catalog-db --template {{.data.username}} | base64 -d catalog_user% $ kubectl -n catalog get secrets catalog-db --template {{.data.password}} | base64 -d default_password% Hãy tạo một secret mới catalog-sealed-db. Chúng ta sẽ tạo một tập tin mới new-catalog-db.yaml với các khóa và giá trị giống như Secret catalog-db.\nmanifests/modules/security/sealed-secrets/new-catalog-db.yaml Bây giờ, hãy tạo các biểu mẫu SealedSecret YAML với kubeseal.\n$ kubeseal --format=yaml \u0026lt; ~/environment/eks-workshop/modules/security/sealed-secrets/new-catalog-db.yaml \\ \u0026gt; /tmp/sealed-catalog-db.yaml Hoặc, bạn có thể lấy khóa công khai từ bộ điều khiển và sử dụng nó ngoại tuyến để niêm phong Secret của bạn:\n$ kubeseal --fetch-cert \u0026gt; /tmp/public-key-cert.pem $ kubeseal --cert=/tmp/public-key-cert.pem --format=yaml \u0026lt; ~/environment/eks-workshop/modules/security/sealed-secrets/new-catalog-db.yaml \\ \u0026gt; /tmp/sealed-catalog-db.yaml Nó sẽ tạo một sealed-secret với nội dung sau:\napiVersion: bitnami.com/v1alpha1 kind: SealedSecret metadata: creationTimestamp: null name: catalog-sealed-db namespace: catalog spec: encryptedData: password: AgBe(...)R91c username: AgBu(...)Ykc= template: data: null metadata: creationTimestamp: null name: catalog-sealed-db namespace: catalog type: Opaque Hãy triển khai SealedSecret này lên cụm EKS của bạn:\n$ kubectl apply -f /tmp/sealed-catalog-db.yaml Nhật ký của bộ điều khiển cho thấy rằng nó nhận SealedSecret tùy chỉnh vừa được triển khai, mở niêm phong nó để tạo ra một Secret thường.\n$ kubectl logs deployments/sealed-secrets-controller -n kube-system 2022/11/07 04:28:27 Updating catalog/catalog-sealed-db 2022/11/07 04:28:27 Event(v1.ObjectReference{Kind:\u0026#34;SealedSecret\u0026#34;, Namespace:\u0026#34;catalog\u0026#34;, Name:\u0026#34;catalog-sealed-db\u0026#34;, UID:\u0026#34;a2ae3aef-f475-40e9-918c-697cd8cfc67d\u0026#34;, APIVersion:\u0026#34;bitnami.com/v1alpha1\u0026#34;, ResourceVersion:\u0026#34;23351\u0026#34;, FieldPath:\u0026#34;\u0026#34;}): type: \u0026#39;Normal\u0026#39; reason: \u0026#39;Unsealed\u0026#39; SealedSecret unsealed successfully Kiểm tra xem Secret catalog-sealed-db đã được mở niêm phong từ SealedSecret và được triển khai bởi bộ điều khiển vào namespace secure-secrets.\n$ kubectl get secret -n catalog catalog-sealed-db NAME TYPE DATA AGE catalog-sealed-db Opaque 4 7m51s Hãy triển khai lại triển khai catalog đọc từ Secret trên. Chúng tôi đã cập nhật triển khai catalog để đọc Secret catalog-sealed-db như sau:\nmodules/security/sealed-secrets/deployment.yaml\rDeployment/catalog $ kubectl apply -k ~/environment/eks-workshop/modules/security/sealed-secrets $ kubectl rollout status -n catalog deployment/catalog --timeout 30s catalog-sealed-db là một tài nguyên SealedSecret an toàn để lưu trữ trong một kho Git cùng với các biểu mẫu YAML liên quan đến các tài nguyên Kubernetes khác như DaemonSets, Deployments, ConfigMaps vv. được triển khai trong cụm của bạn. Bạn sau đó có thể sử dụng quy trình làm việc GitOps để quản lý việc triển khai các tài nguyên này lên cụm của bạn.\n"
},
{
	"uri": "//localhost:1313/vi/7-pod-security-standards/7.3-restricted-pss-profile/",
	"title": "Restricted profile",
	"tags": [],
	"description": "",
	"content": "Cuối cùng, chúng ta có thể xem xét Restricted profile, đó là chính sách bị hạn chế nặng nhất theo các thực hành tốt nhất hiện tại của Pod hardening. Thêm nhãn vào namespace assets để kích hoạt tất cả các chế độ PSA cho Restricted PSS profile:\nmodules/security/pss-psa/restricted-namespace/namespace.yaml\rNamespace/assets Chạy Kustomize để áp dụng thay đổi này để thêm nhãn vào namespace assets:\n$ kubectl apply -k ~/environment/eks-workshop/modules/security/pss-psa/restricted-namespace Cảnh báo: các pod hiện tại trong namespace \u0026#34;assets\u0026#34; vi phạm mức thực thi PodSecurity mới \u0026#34;restricted:latest\u0026#34; Cảnh báo: assets-d59d88b99-flkgp: allowPrivilegeEscalation != false, runAsNonRoot != true, seccompProfile namespace/assets configured serviceaccount/assets unchanged configmap/assets unchanged service/assets unchanged deployment.apps/assets unchanged Tương tự như Baseline profile, chúng ta nhận được cảnh báo rằng Deployment của assets đang vi phạm Restricted profile.\n$ kubectl -n assets delete pod --all pod \u0026#34;assets-d59d88b99-flkgp\u0026#34; deleted Các Pod không được tạo lại:\n$ kubectl -n assets get pod Không tìm thấy tài nguyên trong namespace assets. Đầu ra trên cho thấy PSA không cho phép tạo ra các Pod trong Namespace assets, vì cấu hình bảo mật của Pod vi phạm Restricted PSS profile. Hành vi này giống như chúng ta đã thấy trước đó ở phần trước.\nTrong trường hợp của Restricted profile, thực tế chúng ta cần khóa một số cấu hình bảo mật một cách tích cực để đáp ứng profile đó. Hãy thêm một số điều khiển bảo mật vào cấu hình Pod để tuân thủ với Privileged PSS profile được cấu hình cho namespace assets:\nmodules/security/pss-psa/restricted-workload/deployment.yaml\rDeployment/assets Chạy Kustomize để áp dụng những thay đổi này, sau đó chúng ta sẽ tạo lại Deployment:\n$ kubectl apply -k ~/environment/eks-workshop/modules/security/pss-psa/restricted-workload namespace/assets unchanged serviceaccount/assets unchanged configmap/assets unchanged service/assets unchanged deployment.apps/assets configured Bây giờ, chạy các lệnh dưới đây để kiểm tra PSA cho phép việc tạo ra Deployment và Pod với các thay đổi trên trong namespace assets:\n$ kubectl -n assets get pod NAME READY STATUS RESTARTS AGE assets-8dd6fc8c6-9kptf 1/1 Running 0 3m6s Đầu ra trên cho thấy rằng PSA đã cho phép vì cấu hình bảo mật của Pod tuân thủ Restricted PSS profile.\nLưu ý rằng các quyền bảo mật được nêu trên không phải là danh sách toàn diện các điều khiển được phép trong Restricted PSS profile. Đối với các điều khiển bảo mật chi tiết được phép / không được phép trong mỗi profile PSS, vui lòng tham khảo tài liệu.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.3-tls-basics/",
	"title": "TLS cơ bản",
	"tags": [],
	"description": "",
	"content": "TLS cơ bản Chứng chỉ (TLS Basics) Chứng chỉ được sử dụng để đảm bảo sự tin tưởng giữa 2 bên trong quá trình giao dịch.\nVí dụ: khi một người dùng cố gắng truy cập máy chủ web, các chứng chỉ tls đảm bảo rằng giao tiếp giữa họ được mã hóa.\nMã hóa đối xứng Đây là một cách mã hóa an toàn, nhưng nó sử dụng cùng một khóa để mã hóa và giải mã dữ liệu và khóa phải được trao đổi giữa người gửi và người nhận, có nguy cơ một hacker có thể truy cập vào khóa và giải mã dữ liệu.\nMã hóa không đối xứng Thay vì sử dụng một khóa duy nhất để mã hóa và giải mã dữ liệu, mã hóa không đối xứng sử dụng một cặp khóa, một khóa riêng tư và một khóa công khai.\nLàm thế nào để xem xét một chứng chỉ và xác minh tính hợp lệ của nó? Ai đã ký và cấp phát chứng chỉ. Nếu bạn tạo ra chứng chỉ, sau đó bạn sẽ phải tự ký chứng chỉ đó; điều này được biết đến là chứng chỉ tự ký. Làm thế nào để tạo chứng chỉ hợp lệ? Làm thế nào để có được chứng chỉ của bạn được ký bởi một người có thẩm quyền? Đó là phần Nhà cung cấp chứng chỉ (Certificate Authority - CA) sẽ làm giúp bạn. Một số CA phổ biến là Symantec, DigiCert, Comodo, GlobalSign v.v.\nPublic Key Infrastructure Certificates naming convention "
},
{
	"uri": "//localhost:1313/vi/4-amazon-eks-pod-identity/",
	"title": "Amazon EKS Pod Identity",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị môi trường của bạn cho phần này: $ prepare-environment security/eks-pod-identity Điều này sẽ thực hiện các thay đổi sau đây vào môi trường lab của bạn:\nTạo một bảng Amazon DynamoDB Tạo một vai trò IAM cho các tải trọng công việc AmazonEKS để truy cập vào bảng DynamoDB Cài đặt EKS Managed Addon cho EKS Pod Identity Agent Cài đặt AWS Load Balancer Controller trong cụm Amazon EKS Ứng dụng trong các container của một Pod có thể sử dụng một SDK AWS được hỗ trợ hoặc AWS CLI để thực hiện các yêu cầu API đến các dịch vụ AWS bằng cách sử dụng quyền quản lý danh tính và truy cập (IAM) AWS. Ví dụ, các ứng dụng có thể cần tải tệp lên một bucket S3 hoặc truy vấn một bảng DynamoDB, và để làm điều đó, họ phải ký các yêu cầu API AWS của mình bằng các thông tin đăng nhập AWS. Amazon EKS Pod Identity cung cấp khả năng quản lý thông tin đăng nhập cho các ứng dụng của bạn, tương tự như cách Mẫu Amazon EC2 Instance cung cấp thông tin đăng nhập cho các thể hiện. Thay vì tạo và phân phối thông tin đăng nhập AWS của bạn cho các container hoặc sử dụng Amazon EC2 instance\u0026rsquo;s Role, bạn có thể liên kết một Vai trò IAM với một Tài khoản Dịch vụ Kubernetes và cấu hình Pods của bạn với nó. Kiểm tra tài liệu EKS tại đây để biết danh sách chính xác các phiên bản được hỗ trợ.\nTrong chương này, chúng ta sẽ cấu hình lại một trong các thành phần ứng dụng mẫu để tận dụng API AWS và cung cấp cho nó các đặc quyền phù hợp.\n"
},
{
	"uri": "//localhost:1313/vi/3-iam-roles-for-service-accounts/3.4-applying-irsa/",
	"title": "Áp dụng IRSA",
	"tags": [],
	"description": "",
	"content": "Áp dụng IRSA Để sử dụng IAM Role cho các Service Account trong EKS cluster của bạn, một IAM OIDC Identity Provider phải được tạo và liên kết với một cụm. Một OIDC đã được cung cấp và liên kết với EKS clusterEKS của bạn:\nĐi đến Identity Providers trong Bảng điều khiển IAM:\nhttps://console.aws.amazon.com/iamv2/home#/identity_providers\nBạn sẽ thấy một nhà cung cấp OIDC đã được tạo cho cluster EKS của bạn:\nMột lựa chọn khác là sử dụng AWS CLI để xác minh IAM OIDC Identity Provider.\n$ aws iam list-open-id-connect-providers { \u0026#34;OpenIDConnectProviderList\u0026#34;: [ { \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::012345678901:oidc-provider/oidc.eks.us-east-2.amazonaws.com/id/7185F12D2B62B8DA97B0ECA713F66C86\u0026#34; } ] } Và xác minh sự liên kết của nó với EKS cluster của chúng tôi.\n$ aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --query \u0026#39;cluster.identity\u0026#39; { \u0026#34;oidc\u0026#34;: { \u0026#34;issuer\u0026#34;: \u0026#34;https://oidc.eks.us-west-2.amazonaws.com/id/7185F12D2B62B8DA97B0ECA713F66C86\u0026#34; } } Một IAM Role cung cấp các quyền cần thiết cho dịch vụ carts để đọc và ghi vào bảng DynamoDB đã được tạo cho bạn. Bạn có thể xem chính sách như sau:\n$ aws iam get-policy-version \\ --version-id v1 --policy-arn \\ --query \u0026#39;PolicyVersion.Document\u0026#39; \\ arn:aws:iam::${AWS_ACCOUNT_ID}:policy/${EKS_CLUSTER_NAME}-carts-dynamo | jq . { \u0026#34;Statement\u0026#34;: [ { \u0026#34;Action\u0026#34;: \u0026#34;dynamodb:*\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:dynamodb:us-west-2:1234567890:table/eks-workshop-carts\u0026#34;, \u0026#34;arn:aws:dynamodb:us-west-2:1234567890:table/eks-workshop-carts/index/*\u0026#34; ], \u0026#34;Sid\u0026#34;: \u0026#34;AllAPIActionsOnCart\u0026#34; } ], \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34; } Role cũng đã được cấu hình với mối quan hệ tin cậy phù hợp cho phép nhà cung cấp OIDC liên kết với EKS clusterEKS của chúng tôi giả định Role này miễn là chủ đề là Service Account cho thành phần carts. Bạn có thể xem như sau:\n$ aws iam get-role \\ --query \u0026#39;Role.AssumeRolePolicyDocument\u0026#39; \\ --role-name ${EKS_CLUSTER_NAME}-carts-dynamo | jq . { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: \u0026#34;arn:aws:iam::1234567890:oidc-provider/oidc.eks.us-west-2.amazonaws.com/id/22E1209C76AE64F8F612F8E703E5BBD7\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;oidc.eks.us-west-2.amazonaws.com/id/22E1209C76AE64F8F612F8E703E5BBD7:sub\u0026#34;: \u0026#34;system:serviceaccount:carts:carts\u0026#34; } } } ] } Tất cả những gì còn lại là để cấu hình lại đối tượng Service Account liên kết với ứng dụng carts, thêm chú thích cần thiết vào đó, để IRSA có thể cung cấp quyền hợp lệ cho Pods sử dụng IAM Role ở trên. Hãy xác minh SA liên kết với Triển khai carts.\n$ kubectl -n carts describe deployment carts | grep \u0026#39;Service Account\u0026#39; Service Account: cart Bây giờ hãy kiểm tra giá trị của CARTS_IAM_ROLE sẽ cung cấp ARN của IAM Role cho chú thích Service Account.\n$ echo $CARTS_IAM_ROLE arn:aws:iam::1234567890:role/eks-workshop-carts-dynamo Sau khi chúng ta đã xác minh IAM Role sẽ được sử dụng, chúng ta có thể chạy Kustomize để áp dụng thay đổi lên Service Account.\n$ kubectl kustomize ~/environment/eks-workshop/modules/security/irsa/service-account \\ | envsubst | kubectl apply -f- Điều này sẽ sửa đổi Service Account như sau:\nmodules/security/irsa/service-account/carts-serviceAccount.yaml\rServiceAccount/carts Xác minh xem Service Account đã được chú thích hay không.\n$ kubectl describe sa carts -n carts | grep Annotations Annotations: eks.amazonaws.com/role-arn: arn:aws:iam::1234567890:role/eks-workshop-carts-dynamo Với Service Account được cập nhật, bây giờ chúng ta chỉ cần khởi động lại Pod carts để nó nhận thay đổi:\nbash\r$ kubectl rollout restart -n carts deployment/carts\rdeployment.apps/carts restarted\r$ kubectl rollout status -n carts deployment/carts "
},
{
	"uri": "//localhost:1313/vi/8-policy-management-with-kyverno/8.4-reports--auditing/",
	"title": "Creating a Simple Policy",
	"tags": [],
	"description": "",
	"content": "Báo cáo Chính sách của Kyverno Kyverno cũng bao gồm một công cụ Báo cáo Chính sách sử dụng định dạng mở được xác định bởi Nhóm làm việc Chính sách Kubernetes và triển khai như tài nguyên tùy chỉnh trong cụm. Kyverno phát ra các báo cáo này khi các hành động nhập cảnh như TẠO, CẬP NHẬT, và XÓA được thực hiện trong cụm, chúng cũng được tạo ra như là kết quả của các quét nền kiểm tra chính sách trên các tài nguyên đã tồn tại.\nCho đến nay trong buổi thực hành, chúng ta đã tạo một số Chính sách cho các quy tắc cụ thể. Khi một tài nguyên được phù hợp với một hoặc nhiều quy tắc theo định nghĩa của chính sách và vi phạm bất kỳ quy tắc nào, một mục sẽ được tạo ra trong báo cáo cho mỗi vi phạm, dẫn đến nhiều mục nếu cùng một tài nguyên phù hợp và vi phạm nhiều quy tắc. Khi các tài nguyên bị xóa, mục của chúng sẽ được loại bỏ khỏi các báo cáo, có nghĩa là Báo cáo Kyverno luôn đại diện cho trạng thái hiện tại của cụm và không ghi lại thông tin lịch sử.\nNhư đã thấy trước đó, Kyverno có hai loại validationFailureAction, chế độ Kiểm tra sẽ cho phép tài nguyên được tạo ra và báo cáo hành động trong các Báo cáo Chính sách, hoặc Bắt buộc sẽ từ chối việc tạo tài nguyên, nhưng cũng không thêm mục vào các Báo cáo Chính sách. Ví dụ, nếu một Chính sách trong chế độ Kiểm tra chứa một quy tắc đơn giản yêu cầu tất cả các tài nguyên phải thiết lập nhãn CostCenter và một Pod được tạo ra mà không có nhãn đó, Kyverno sẽ cho phép tạo Pod nhưng ghi lại nó là kết quả FAIL trong một Báo cáo Chính sách do vi phạm quy tắc. Nếu Chính sách này cùng chế độ Bắt buộc, Kyverno sẽ ngăn chặn ngay lập tức việc tạo tài nguyên và điều này sẽ không tạo ra một mục trong Báo cáo Chính sách, tuy nhiên nếu Pod được tạo ra tuân thủ quy tắc, nó sẽ được báo cáo là PASS trong báo cáo. Có thể kiểm tra các hành động bị chặn trong các sự kiện Kubernetes cho Namespace nơi hành động được yêu cầu.\nBây giờ, chúng ta sẽ kiểm tra trạng thái tuân thủ của cụm của chúng ta đối với các chính sách chúng ta đã tạo cho đến nay trong buổi thực hành này với một tổng quan về các Báo cáo Chính sách được tạo ra.\n$ kubectl get policyreports -A NAMESPACE NAME PASS FAIL WARN ERROR SKIP AGE assets cpol-baseline-policy 3 0 0 0 0 19m assets cpol-require-labels 0 3 0 0 0 27m assets cpol-restrict-image-registries 3 0 0 0 0 25m carts cpol-baseline-policy 6 0 0 0 0 19m carts cpol-require-labels 0 6 0 0 0 27m carts cpol-restrict-image-registries 3 3 0 0 0 25m catalog cpol-baseline-policy 5 0 0 0 0 19m catalog cpol-require-labels 0 5 0 0 0 27m catalog cpol-restrict-image-registries 5 0 0 0 0 25m checkout cpol-baseline-policy 6 0 0 0 0 19m checkout cpol-require-labels 0 6 0 0 0 27m checkout cpol-restrict-image-registries 6 0 0 0 0 25m default cpol-baseline-policy 2 0 0 0 0 19m default cpol-require-labels 2 0 0 0 0 13m default cpol-restrict-image-registries 1 1 0 0 0 13m kube-system cpol-baseline-policy 4 8 0 0 0 19m kube-system cpol-require-labels 0 12 0 0 0 27m kube-system cpol-restrict-image-registries 0 12 0 0 0 25m kyverno cpol-baseline-policy 24 0 0 0 0 19m kyverno cpol-require-labels 0 24 0 0 0 27m kyverno cpol-restrict-image-registries 0 24 0 0 0 25m orders cpol-baseline-policy 6 0 0 0 0 19m orders cpol-require-labels 0 6 0 0 0 27m orders cpol-restrict-image-registries 6 0 0 0 0 25m rabbitmq cpol-baseline-policy 2 0 0 0 0 19m rabbitmq cpol-require-labels 0 2 0 0 0 27m rabbitmq cpol-restrict-image-registries 2 0 0 0 0 25m ui cpol-baseline-policy 3 0 0 0 0 19m ui cpol-require-labels 0 3 0 0 0 27m ui cpol-restrict-image-registries 3 0 0 0 0 25m Đầu ra có thể thay đổi.\nVì chúng ta chỉ làm việc với ClusterPolicies, bạn có thể thấy trong đầu ra trên một số Báo cáo đã được tạo ra trên tất cả các Namespaces, như cpol-verify-image, cpol-baseline-policy, và cpol-restrict-image-registries và không chỉ trong Namespace default, nơi chúng ta đã tạo các tài nguyên để được xác nhận. Bạn cũng có thể nhìn thấy trạng thái của các đối tượng như PASS, FAIL, WARN, ERROR, và SKIP.\nNhư đã đề cập trước đó, các hành động bị chặn sẽ tồn tại trong các sự kiện Namespace, hãy xem xét những sự kiện đó bằng cách sử dụng lệnh dưới đây.\n$ kubectl get events | grep block 8m Warning PolicyViolation clusterpolicy/restrict-image-registries Pod default/nginx-public: [validate-registries] fail (blocked); validation error: Unknown Image registry. rule validate-registries failed at path /spec/containers/0/image/ 3m Warning PolicyViolation clusterpolicy/restrict-image-registries Pod default/nginx-public: [validate-registries] fail (blocked); validation error: Unknown Image registry. rule validate-registries failed at path /spec/containers/0/image/ Đầu ra có thể thay đổi.\nBây giờ, hãy xem xét kỹ hơn các Báo cáo Chính sách cho Namespace default được sử dụng trong các bài thực hành.\n$ kubectl get policyreports NAME PASS FAIL WARN ERROR SKIP AGE default cpol-baseline-policy 2 0 0 0 0 19m default cpol-require-labels 2 0 0 0 0 13m default cpol-restrict-image-registries 1 1 0 0 0 13m Kiểm tra xem cho ClusterPolicy restrict-image-registries, chúng ta chỉ có một Báo cáo FAIL và một Báo cáo PASS. Điều này đã xảy ra vì tất cả các ClusterPolicies được tạo với chế độ Bắt buộc, và như đã đề cập, các tài nguyên bị chặn không được báo cáo, cũng như các tài nguyên đã chạy trước đó có thể vi phạm các quy tắc chính sách, đã được loại bỏ.\nPod nginx, mà chúng ta để chạy với một hình ảnh có sẵn công khai, là tài nguyên duy nhất còn lại vi phạm chính sách restrict-image-registries, và nó được hiển thị trong báo cáo.\nHãy xem chi tiết hơn các vi phạm cho Chính sách này bằng cách mô tả một báo cáo cụ thể. Như được thể hiện trong ví dụ dưới đây, sử dụng lệnh kubectl describe cho Báo cáo cpol-restrict-image-registries để xem các kết quả xác nhận cho ClusterPolicy restrict-image-registries.\n$ kubectl describe policyreport cpol-restrict-image-registries Name: cpol-restrict-image-registries Namespace: default Labels: app.kubernetes.io/managed-by=kyverno cpol.kyverno.io/restrict-image-registries=607025 Annotations: \u0026lt;none\u0026gt; API Version: wgpolicyk8s.io/v1alpha2 Kind: PolicyReport Metadata: Creation Timestamp: 2024-01-18T01:03:40Z Generation: 1 Resource Version: 607320 UID: 7abb6c11-9610-4493-ab1e-df94360ce773 Results: Message: validation error: Unknown Image registry. rule validate-registries failed at path /spec/containers/0/image/ Policy: restrict-image-registries Resources: API Version: v1 Kind: Pod Name: nginx Namespace: default UID: dd5e65a9-66b5-4192-89aa-a291d150807d Result: fail Rule: validate-registries Scored: true Source: kyverno Timestamp: Nanos: 0 Seconds: 1705539793 Message: validation rule \u0026#39;validate-registries\u0026#39; passed. Policy: restrict-image-registries Resources: API Version: v1 Kind: Pod Name: nginx-ecr Namespace: default UID: e638aad7-7fff-4908-bbe8-581c371da6e3 Result: pass Rule: validate-registries Scored: true Source: kyverno Timestamp: Nanos: 0 Seconds: 1705539793 Summary: Error: 0 Fail: 1 Pass: 1 Skip: 0 Warn: 0 Events: \u0026lt;none\u0026gt; Đầu ra trên hiển thị xác nhận chính sách của Pod nginx nhận kết quả fail và thông báo lỗi xác nhận. Ngược lại, xác nhận chính sách của nginx-ecr nhận kết quả pass. Theo dõi các báo cáo theo cách này có thể là một gánh nặng đối với các quản trị viên. Kyverno cũng hỗ trợ một công cụ dựa trên giao diện đồ họa cho Báo cáo Chính sách. Điều này nằm ngoài phạm vi của bài thực hành này.\nTrong bài lab này, bạn đã học cách bổ sung cấu hình PSA/PSS Kubernetes của mình bằng Kyverno. Các Tiêu chuẩn Bảo mật Pod (PSS) và cài đặt Kubernetes trong cây, thực hiện các tiêu chuẩn Bảo mật Pod (PSP), cung cấp các khối xây dựng tốt cho việc quản lý bảo mật pod. Đa số người dùng chuyển từ Chính sách Bảo mật Pod Kubernetes (PSP) nên thành công khi sử dụng các tính năng PSA/PSS.\nKyverno bổ sung trải nghiệm người dùng được tạo ra bởi PSA/PSS, bằng cách tận dụng cài đặt bảo mật pod Kubernetes trong cây và cung cấp một số cải tiến hữu ích cho việc vận hành chính sách. Bạn có thể sử dụng Kyverno để quản lý việc sử dụng nhãn bảo mật pod một cách đúng đắn. Ngoài ra, bạn cũng có thể sử dụng quy tắc validate.podSecurity mới của Kyverno để dễ dàng quản lý các tiêu chuẩn bảo mật pod với tính linh hoạt và trải nghiệm người dùng tốt hơn. Và, với Kyverno CLI, bạn có thể tự động hóa việc đánh giá chính sách, phía trước của các cụm của bạn.\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.2-managing-secrets-with-aws-secrets-manager/5.2.4-external-secrets-operator/",
	"title": "External Secrets Operator",
	"tags": [],
	"description": "",
	"content": "External Secrets Operator (Trình vận hành secret từ bên thứ ba) Bây giờ chúng ta có thể khám phá tích hợp với Secrets Managed sử dụng External Secrets operator. Điều này đã được cài đặt trong cluster EKS của chúng ta:\n$ kubectl -n external-secrets get pods NAME READY STATUS RESTARTS AGE external-secrets-6d95d66dc8-5trlv 1/1 Running 0 7m external-secrets-cert-controller-774dff987b-krnp7 1/1 Running 0 7m external-secrets-webhook-6565844f8f-jxst8 1/1 Running 0 7m $ kubectl -n external-secrets get sa NAME SECRETS AGE default 0 7m external-secrets-sa 0 7m Như chúng ta có thể thấy, có một ServiceAccount có tên external-secrets-sa được liên kết với một vai trò IAM thông qua IRSA, với quyền truy cập vào AWS Secrets Manager để lấy thông tin về secrets.\n$ kubectl -n external-secrets describe sa external-secrets-sa | grep Annotations Annotations: eks.amazonaws.com/role-arn: arn:aws:iam::068535243777:role/eks-workshop-external-secrets-sa-irsa Ngoài ra, chúng ta cần tạo một tài nguyên cluster mới có tên là ClusterSecretStore, đây là một SecretStore trên toàn cụm có thể được tham chiếu bởi tất cả ExternalSecrets từ mọi namespace.\nmanifests/modules/security/secrets-manager/cluster-secret-store.yaml $ cat ~/environment/eks-workshop/modules/security/secrets-manager/cluster-secret-store.yaml \\ | envsubst | kubectl apply -f - Hãy xem xét kỹ hơn về các thông số của tài nguyên mới được tạo.\n$ kubectl get clustersecretstores.external-secrets.io NAME AGE STATUS CAPABILITIES READY cluster-secret-store 81s Valid ReadWrite True $ kubectl get clustersecretstores.external-secrets.io cluster-secret-store -o yaml | yq \u0026#39;.spec\u0026#39; provider: aws: auth: jwt: serviceAccountRef: name: external-secrets-sa namespace: external-secrets region: us-west-2 service: SecretsManager Bạn có thể thấy ở đây, nó đang sử dụng một JSON Web Token (jwt), được tham chiếu đến ServiceAccount mà chúng ta vừa kiểm tra, để đồng bộ với AWS Secrets Manager.\nHãy tiếp tục và tạo một ExternalSecret mô tả những dữ liệu nào sẽ được lấy từ AWS Secrets Manager, cách dữ liệu sẽ được biến đổi và lưu trữ như một Kubernetes Secret. Sau đó, chúng ta có thể patch Deployment catalog của mình để sử dụng External Secret làm nguồn cho thông tin xác thực.\nmodules/security/secrets-manager/external-secrets/kustomization.yaml\rDeployment/catalog\rExternalSecret/catalog-external-secret $ kubectl kustomize ~/environment/eks-workshop/modules/security/secrets-manager/external-secrets/ \\ | envsubst | kubectl apply -f- $ kubectl rollout status -n catalog deployment/catalog --timeout=120s Kiểm tra tài nguyên ExternalSecret mới tạo.\n$ kubectl -n catalog get externalsecrets.external-secrets.io NAME STORE REFRESH INTERVAL STATUS READY catalog-external-secret cluster-secret-store 1h SecretSynced True Xác minh rằng tài nguyên có trạng thái SecretSynced, có nghĩa là nó đã được đồng bộ thành công từ AWS Secrets Manager. Hãy xem xét kỹ hơn các thông số của tài nguyên này.\n$ kubectl -n catalog get externalsecrets.external-secrets.io catalog-external-secret -o yaml | yq \u0026#39;.spec\u0026#39; dataFrom: - extract: conversionStrategy: Default decodingStrategy: None key: eks-workshop/catalog-secret refreshInterval: 1h secretStoreRef: kind: ClusterSecretStore name: cluster-secret-store target: creationPolicy: Owner deletionPolicy: Retain Chú ý đến các tham số key và secretStoreRef trỏ đến secret mà chúng ta đã lưu trữ trên AWS Secrets Manager, và ClusterSecretStore đã tạo trước đó. Cũng như refreshInterval được đặt là 1 giờ, có nghĩa là giá trị từ secret này sẽ được kiểm tra và cập nhật mỗi giờ.\nNhưng làm thế nào chúng ta sử dụng ExternalSecret này trong các Pod của mình? Sau khi chúng ta tạo tài nguyên này, nó tự động tạo ra một secret Kubernetes có cùng tên trong namespace.\n$ kubectl -n catalog get secrets NAME TYPE DATA AGE catalog-db Opaque 2 21h catalog-external-secret Opaque 2 1m catalog-secret Opaque 2 5h40m Hãy xem xét kỹ hơn về secret này.\n$ kubectl -n catalog get secret catalog-external-secret -o yaml | yq \u0026#39;.metadata.ownerReferences\u0026#39; - apiVersion: external-secrets.io/v1beta1 blockOwnerDeletion: true controller: true kind: ExternalSecret name: catalog-external-secret uid: b8710001-366c-44c2-8e8d-462d85b1b8d7 Thấy rằng nó có một ownerReference trỏ đến External Secrets Operator.\nBây giờ kiểm tra rằng pod catalog đã được cập nhật với các giá trị từ secret mới này, và\u0026hellip;\nNó đã hoạt động!\n$ kubectl -n catalog get pods NAME READY STATUS RESTARTS AGE catalog-777c4d5dc8-lmf6v 1/1 Running 0 1m catalog-mysql-0 1/1 Running 0 24h $ kubectl -n catalog get deployment catalog -o yaml | yq \u0026#39;.spec.template.spec.containers[] | .env\u0026#39; - name: DB_USER valueFrom: secretKeyRef: key: username name: catalog-external-secret - name: DB_PASSWORD valueFrom: secretKeyRef: key: password name: catalog-external-secret Kết luận Tóm lại không có lựa chọn tốt nhất giữa AWS Secrets and Configuration Provider (ASCP) và External Secrets Operator (ESO) để quản lý secrets được lưu trữ trên AWS Secrets Manager.\nCả hai công cụ đều có những ưu điểm cụ thể của chúng, ví dụ, ASCP có thể giúp bạn tránh tiết lộ secrets như biến môi trường, gắn chúng như volumes trực tiếp từ AWS Secrets Manager vào một Pod, nhược điểm là cần phải quản lý những volumes đó. Trong khi đó, ESO làm cho việc quản lý vòng đời của Kubernetes Secrets dễ dàng hơn, có cũng một SecretStore trên toàn cụm, tuy nhiên nó không cho phép bạn sử dụng Secrets như volumes. Tất cả phụ thuộc vào trường hợp sử dụng của bạn, và có cả hai có thể mang lại cho bạn nhiều linh hoạt và bảo mật hơn với quản lý Secrets.\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/5.3-securing-secrets-using-sealed-secrets/5.3.4-managing-the-sealing-key/",
	"title": "Quản lý khoá niêm phong",
	"tags": [],
	"description": "",
	"content": "Quản lý khoá niêm phong Để giải mã dữ liệu được mã hóa bên trong một SealedSecret, bạn cần sử dụng khóa niêm phong được quản lý bởi bộ điều khiển. Có thể có tình huống khi bạn cố gắng khôi phục trạng thái ban đầu của một cụm sau một thảm họa hoặc bạn muốn tận dụng quy trình GitOps để triển khai các tài nguyên Kubernetes, bao gồm SealedSecrets, từ một kho lưu trữ Git và tạo một cụm EKS mới. Bộ điều khiển được triển khai trong cụm EKS mới phải sử dụng cùng một khóa niêm phong để có thể mở niêm phong các SealedSecrets.\nChạy lệnh sau để lấy khóa niêm phong từ cụm. Trong môi trường sản xuất, việc sử dụng Kubernetes RBAC để cấp quyền cho một tập hợp hạn chế các khách hàng thực hiện thao tác này được coi là một thực hành tốt.\n$ kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml \\ \u0026gt; /tmp/master-sealing-key.yaml Để kiểm tra hoạt động, hãy xóa Secret chứa khóa niêm phong và tái chế bộ điều khiển Sealed Secrets:\n$ kubectl delete secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key $ kubectl -n kube-system delete pod -l name=sealed-secrets-controller $ kubectl wait --for=condition=Ready --timeout=30s pods -l name=sealed-secrets-controller -n kube-system Bây giờ, chúng ta sẽ kiểm tra nhật ký của bộ điều khiển. Lưu ý rằng nó không thể giải mã SealedSecret:\n$ kubectl logs deployment/sealed-secrets-controller -n kube-system [...] 2022/11/18 22:47:42 Updating catalog/catalog-sealed-db 2022/11/18 22:47:43 Error updating catalog/catalog-sealed-db, giving up: no key could decrypt secret (password, username, endpoint, name) E1118 22:47:43.030178 1 controller.go:175] no key could decrypt secret (password, username, endpoint, name) 2022/11/18 22:47:43 Event(v1.ObjectReference{Kind:\u0026#34;SealedSecret\u0026#34;, Namespace:\u0026#34;catalog\u0026#34;, Name:\u0026#34;catalog-sealed-db\u0026#34;, UID:\u0026#34;a6705e6f-72a1-43f5-8c0b-4f45b9b6f5fb\u0026#34;, APIVersion:\u0026#34;bitnami.com/v1alpha1\u0026#34;, ResourceVersion:\u0026#34;519192\u0026#34;, FieldPath:\u0026#34;\u0026#34;}): type: \u0026#39;Warning\u0026#39; reason: \u0026#39;ErrUnsealFailed\u0026#39; Failed to unseal: no key could decrypt secret (password, username, endpoint, name) Điều này xảy ra vì chúng ta đã xóa khóa niêm phong, làm cho bộ điều khiển tạo ra một khóa mới khi nó khởi động. Điều này thực tế làm cho tất cả các tài nguyên SealedSecret của chúng ta không thể truy cập được bởi bộ điều khiển này. May mắn thay, chúng ta đã trước đó lưu nó vào /tmp/master-sealing-key.yaml để có thể tạo lại nó trong cụm EKS:\n$ kubectl apply -f /tmp/master-sealing-key.yaml $ kubectl -n kube-system delete pod -l name=sealed-secrets-controller $ kubectl wait --for=condition=Ready --timeout=30s pods -l name=sealed-secrets-controller -n kube-system Kiểm tra nhật ký một lần nữa sẽ thấy rằng lần này bộ điều khiển đã nhận được khóa niêm phong mà chúng ta đã khôi phục và đã mở niêm phong catalog-sealed-db của chúng ta:\n$ kubectl logs deployment/sealed-secrets-controller -n kube-system [...] 2022/11/18 22:52:51 Updating catalog/catalog-sealed-db 2022/11/18 22:52:51 Event(v1.ObjectReference{Kind:\u0026#34;SealedSecret\u0026#34;, Namespace:\u0026#34;catalog\u0026#34;, Name:\u0026#34;catalog-sealed-db\u0026#34;, UID:\u0026#34;a6705e6f-72a1-43f5-8c0b-4f45b9b6f5fb\u0026#34;, APIVersion:\u0026#34;bitnami.com/v1alpha1\u0026#34;, ResourceVersion:\u0026#34;519192\u0026#34;, FieldPath:\u0026#34;\u0026#34;}): type: \u0026#39;Normal\u0026#39; reason: \u0026#39;Unsealed\u0026#39; SealedSecret unsealed successfully Tệp /tmp/master-sealing-key.yaml chứa cặp khóa công khóa riêng được tạo bởi bộ điều khiển. Nếu tệp này bị lộ, tất cả các biểu hiện SealedSecret có thể được mở niêm phong và thông tin nhạy cảm được mã hóa mà chúng lưu trữ sẽ được tiết lộ. Do đó, tệp này phải được bảo vệ bằng cách cấp quyền truy cập ít nhất đặc quyền. Đối với hướng dẫn bổ sung về các chủ đề như làm mới khóa niêm phong và quản lý khóa niêm phong thủ công, vui lòng tham khảo tài liệu.\nMột lựa chọn để bảo mật khóa niêm phong là lưu nội dung của tệp /tmp/master-sealing-key.yaml dưới dạng tham số SecureString trong AWS Systems Manager Parameter Store. Tham số có thể được bảo vệ bằng cách sử dụng một khóa quản lý khách hàng KMS (CMK) và bạn có thể sử dụng Chính sách khóa để hạn chế tập hợp các nguyên tắc IAM nào có thể sử dụng khóa này để lấy tham số. Bên cạnh đó, bạn cũng có thể kích hoạt tự động làm mới của CMK này trong KMS.\nLưu ý rằng các tham số tier tiêu chuẩn hỗ trợ một giá trị tham số tối đa là 4096 ký tự. Do đó, với kích thước của tệp master.yaml, bạn sẽ phải lưu nó dưới dạng tham số trong tier Advanced.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.4-tls-in-kubernetes/",
	"title": "TLS in Kubernetes",
	"tags": [],
	"description": "",
	"content": "TLS in Kubernetes Đảm bảo tất cả các dịch vụ khác nhau trong cụm sử dụng chứng chỉ máy chủ và tất cả các máy khách sử dụng chứng chỉ máy khách để xác minh họ là người họ nói họ là.\nServer Certificates for Servers Client Certificates for Clients Hãy xem các thành phần khác nhau trong cụm k8s và xác định các máy chủ và máy khách khác nhau cùng với việc ai nói chuyện với ai.\nGenerate Certificates Có các công cụ khác nhau như easyrsa, openssl hoặc cfssl vv. hoặc nhiều công cụ khác để tạo chứng chỉ.\nCertificate Authority (CA) Generate Keys $ openssl genrsa -out ca.key 2048 Generate CSR $ openssl req -new -key ca.key -subj \u0026#34;/CN=KUBERNETES-CA\u0026#34; -out ca.csr Sign certificates $ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt Generating Client Certificates Generate Keys $ openssl genrsa -out admin.key 2048 Generate CSR $ openssl req -new -key admin.key -subj \u0026#34;/CN=kube-admin\u0026#34; -out admin.csr Sign certificates $ openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt Certificate with admin privilages $ openssl req -new -key admin.key -subj \u0026#34;/CN=kube-admin/O=system:masters\u0026#34; -out admin.csr "
},
{
	"uri": "//localhost:1313/vi/4-amazon-eks-pod-identity/4.4-using-eks-pod-identity/",
	"title": "Using EKS Pod Identity",
	"tags": [],
	"description": "",
	"content": "Using EKS Pod Identity Để sử dụng EKS Pod Identity trong cụm của bạn, tiện ích EKS Pod Identity Agent phải được cài đặt trên cụm EKS của bạn. Hãy cài đặt nó bằng lệnh dưới đây.\n$ aws eks create-addon --cluster-name $EKS_CLUSTER_NAME --addon-name eks-pod-identity-agent { \u0026#34;addon\u0026#34;: { \u0026#34;addonName\u0026#34;: \u0026#34;eks-pod-identity-agent\u0026#34;, \u0026#34;clusterName\u0026#34;: \u0026#34;eks-workshop\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;CREATING\u0026#34;, \u0026#34;addonVersion\u0026#34;: \u0026#34;v1.1.0-eksbuild.1\u0026#34;, \u0026#34;health\u0026#34;: { \u0026#34;issues\u0026#34;: [] }, \u0026#34;addonArn\u0026#34;: \u0026#34;arn:aws:eks:us-west-2:123456789000:addon/eks-workshop/eks-pod-identity-agent/9ec6cfbd-8c9f-7ff4-fd26-640dda75bcea\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2024-01-12T22:41:01.414000+00:00\u0026#34;, \u0026#34;modifiedAt\u0026#34;: \u0026#34;2024-01-12T22:41:01.434000+00:00\u0026#34;, \u0026#34;tags\u0026#34;: {} } } $ aws eks wait addon-active --cluster-name $EKS_CLUSTER_NAME --addon-name eks-pod-identity-agent Bây giờ hãy xem tiện ích mới đã tạo ra những gì trong cụm EKS của bạn. Bạn có thể thấy một DaemonSet được triển khai trên Namespace kube-system, sẽ chạy một Pod trên mỗi Node trong Cụm của chúng tôi.\n$ kubectl -n kube-system get daemonset eks-pod-identity-agent NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE eks-pod-identity-agent 3 3 3 3 3 \u0026lt;none\u0026gt; 3d21h $ kubectl -n kube-system get pods -l app.kubernetes.io/name=eks-pod-identity-agent NAME READY STATUS RESTARTS AGE eks-pod-identity-agent-4tn28 1/1 Running 0 3d21h eks-pod-identity-agent-hslc5 1/1 Running 0 3d21h eks-pod-identity-agent-thvf5 1/1 Running 0 3d21h Một Vai trò IAM cung cấp các quyền cần thiết cho dịch vụ carts để đọc và ghi vào bảng DynamoDB đã được tạo khi bạn chạy kịch bản prepare-environment trong bước đầu tiên của mô-đun này. Bạn có thể xem chính sách như được hiển thị dưới đây.\n$ aws iam get-policy-version \\ --version-id v1 --policy-arn \\ --query \u0026#39;PolicyVersion.Document\u0026#39; \\ arn:aws:iam::${AWS_ACCOUNT_ID}:policy/${EKS_CLUSTER_NAME}-carts-dynamo | jq . { \u0026#34;Statement\u0026#34;: [ { \u0026#34;Action\u0026#34;: \u0026#34;dynamodb:*\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:dynamodb:us-west-2:1234567890:table/eks-workshop-carts\u0026#34;, \u0026#34;arn:aws:dynamodb:us-west-2:1234567890:table/eks-workshop-carts/index/*\u0026#34; ], \u0026#34;Sid\u0026#34;: \u0026#34;AllAPIActionsOnCart\u0026#34; } ], \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34; } Vai trò cũng đã được cấu hình với mối quan hệ tin cậy phù hợp cho phép Chủ thể Dịch vụ EKS giả định vai trò này cho Pod Identity. Bạn có thể xem như dưới đây với lệnh sau.\n$ aws iam get-role \\ --query \u0026#39;Role.AssumeRolePolicyDocument\u0026#39; \\ --role-name ${EKS_CLUSTER_NAME}-carts-dynamo | jq . { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;pods.eks.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;sts:AssumeRole\u0026#34;, \u0026#34;sts:TagSession\u0026#34; ] } ] } Tiếp theo, chúng ta sẽ sử dụng tính năng Amazon EKS Pod Identity để liên kết một vai trò IAM AWS với tài khoản dịch vụ Kubernetes sẽ được sử dụng bởi triển khai của chúng tôi. Để tạo sự kết hợp, hãy chạy lệnh sau.\n$ aws eks create-pod-identity-association --cluster-name ${EKS_CLUSTER_NAME} \\ --role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/${EKS_CLUSTER_NAME}-carts-dynamo \\ --namespace carts --service-account carts { \u0026#34;association\u0026#34;: { \u0026#34;clusterName\u0026#34;: \u0026#34;eks-workshop\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;carts\u0026#34;, \u0026#34;serviceAccount\u0026#34;: \u0026#34;carts\u0026#34;, \u0026#34;roleArn\u0026#34;: \u0026#34;arn:aws:iam::123456789000:role/eks-workshop-carts-dynamo\u0026#34;, \u0026#34;associationArn\u0026#34;: \u0026#34;arn:aws::123456789000:podidentityassociation/eks-workshop/a-abcdefghijklmnop1\u0026#34;, \u0026#34;associationId\u0026#34;: \u0026#34;a-abcdefghijklmnop1\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;createdAt\u0026#34;: \u0026#34;2024-01-09T16:16:38.163000+00:00\u0026#34;, \u0026#34;modifiedAt\u0026#34;: \u0026#34;2024-01-09T16:16:38.163000+00:00\u0026#34; } } Tất cả những gì còn lại là xác minh rằng Triển khai carts đang sử dụng Tài khoản Dịch vụ carts.\n$ kubectl -n carts describe deployment carts | grep \u0026#39;Service Account\u0026#39; Service Account: carts Với Tài khoản Dịch vụ được xác minh, khởi động lại các Pod carts.\n$ kubectl -n carts rollout restart deployment/carts deployment.apps/carts restarted $ kubectl -n carts rollout status deployment/carts Waiting for deployment \u0026#34;carts\u0026#34; rollout to finish: 1 old replicas are pending termination... deployment \u0026#34;carts\u0026#34; successfully rolled out "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.5-kubeconfig/",
	"title": "KubeConfig",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tìm hiểu về kubeconfig trong Kubernetes.\nClient sử dụng tệp chứng chỉ và khóa để truy vấn API Rest của Kubernetes để lấy danh sách các pod bằng cách sử dụng curl.\nBạn có thể chỉ định điều này bằng cách sử dụng kubectl\nChúng ta có thể di chuyển các thông tin này vào một tệp cấu hình được gọi là kubeconfig. Và chỉ định tệp này như là tùy chọn kubeconfig trong câu lệnh.\n$ kubectl get pods --kubeconfig config Tệp Kubeconfig Tệp kubeconfig có 3 phần\nCụm (Clusters) Ngữ cảnh (Contexts) Người dùng (Users) Để xem tệp hiện tại đang được sử dụng\n$ kubectl config view Bạn có thể chỉ định tệp kubeconfig với kubectl config view bằng cờ \u0026ldquo;\u0026ndash;kubeconfig\u0026rdquo;\n$ kubectl config veiw --kubeconfig=my-custom-config Làm thế nào để cập nhật ngữ cảnh hiện tại của bạn? Hoặc thay đổi ngữ cảnh hiện tại\n$ kubectl config view --kubeconfig=my-custom-config Xem các trợ giúp của kubectl config\n$ kubectl config -h Tài liệu tham khảo K8s https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/ https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#config\n"
},
{
	"uri": "//localhost:1313/vi/5-secrets-management/",
	"title": "Quản lý khoá bí mật",
	"tags": [],
	"description": "",
	"content": "Quản lý khoá bí mật Kubernetes Secret (Khoá bí mật Kubernetes) là một tài nguyên giúp các nhà quản trị cụm quản lý việc triển khai thông tin nhạy cảm như mật khẩu, mã thông báo OAuth và khóa SSH v.v. Các secret này có thể được gắn kết như các thư mục dữ liệu hoặc được tiết lộ như các biến môi trường cho các container trong một Pod, từ đó tách biệt việc triển khai Pod khỏi việc quản lý dữ liệu nhạy cảm cần thiết cho các ứng dụng được container hóa trong một Pod.\nĐã trở thành một thực hành phổ biến cho một Nhóm DevOps quản lý các biểu mẫu YAML cho các nguồn lực Kubernetes khác nhau và kiểm soát phiên bản chúng bằng cách sử dụng một kho Git. Điều này cho phép họ tích hợp một kho Git với luồng làm việc GitOps để thực hiện Cung cấp Liên tục của các nguồn lực này đến một cụm EKS. Kubernetes ẩn dữ liệu nhạy cảm trong một Secret bằng cách sử dụng mã hóa base64 đơn giản, cũng như việc lưu trữ các tệp như vậy trong một kho Git là cực kỳ không an toàn vì nó rất dễ giải mã dữ liệu đã được mã hóa base64. Điều này làm cho việc quản lý các biểu mẫu YAML cho Kubernetes Secrets bên ngoài một cụm trở nên khó khăn.\nCó một số phương pháp khác nhau bạn có thể sử dụng để quản lý secrets, trong chương này về Quản lý Secrets, chúng tôi sẽ bao gồm một vài phương pháp, Sealed Secrets for Kubernetes và AWS Secrets Manager.\n"
},
{
	"uri": "//localhost:1313/vi/3-iam-roles-for-service-accounts/3.5-verifying-dynamodb-access/",
	"title": "Xác nhận khả năng truy cập DynamoDB",
	"tags": [],
	"description": "",
	"content": "Xác nhận khả năng truy cập DynamoDB Bây giờ, với carts Service Account đã được chú thích với vai trò IAM được ủy quyền, pod carts có quyền truy cập vào bảng DynamoDB. Truy cập cửa hàng web lại và điều hướng đến giỏ hàng.\n$ kubectl get service -n ui ui-nlb -o jsonpath=\u0026#34;{.status.loadBalancer.ingress[*].hostname}\u0026#34; k8s-ui-uinlb-647e781087-6717c5049aa96bd9.elb.us-west-2.amazonaws.com Pod carts có thể truy cập vào dịch vụ DynamodDB và giỏ hàng bây giờ có thể truy cập được!\nHãy xem xét kỹ hơn Pod mới carts để xem đang xảy ra điều gì.\n$ kubectl -n carts exec deployment/carts -- env | grep AWS AWS_STS_REGIONAL_ENDPOINTS=regional AWS_DEFAULT_REGION=us-west-2 AWS_REGION=us-west-2 AWS_ROLE_ARN=arn:aws:iam::1234567890:role/eks-workshop-carts-dynamo AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token Các biến môi trường này không được truyền vào bằng cách sử dụng một thứ tương tự ConfigMap hoặc cấu hình trực tiếp trên Deployment. Thay vào đó, các biến này đã được thiết lập bởi IRSA tự động để cho phép SDK AWS nhận các thông tin xác thực tạm thời từ dịch vụ AWS STS.\nNhững điều đáng chú ý là:\nKhu vực được tự động đặt cùng với cụm EKS của chúng ta Các điểm cuối khu vực STS được cấu hình để tránh đặt áp lực quá nhiều lên điểm cuối toàn cầu ở us-east-1 ARN của vai trò khớp với vai trò mà chúng ta đã sử dụng để chú thích ServiceAccount của Kubernetes của chúng ta trước đó Cuối cùng, biến AWS_WEB_IDENTITY_TOKEN_FILE cho SDK AWS biết cách nhận thông tin xác thực bằng cách sử dụng liên minh danh tính web. Điều này có nghĩa là IRSA không cần phải tiêm các thông tin xác thực thông qua một cặp AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY, và thay vào đó các SDK có thể nhận được thông tin xác thực tạm thời thông qua cơ chế OIDC. Bạn có thể đọc thêm về cách hoạt động này trong tài liệu AWS.\n"
},
{
	"uri": "//localhost:1313/vi/4-amazon-eks-pod-identity/4.5-verifying-dynamodb-access/",
	"title": "Xác nhận khả năng truy cập DynamoDB",
	"tags": [],
	"description": "",
	"content": "Bây giờ, với carts Service Account được liên kết với vai trò IAM được ủy quyền, pod carts có quyền truy cập vào bảng DynamoDB. Truy cập cửa hàng web lại và điều hướng đến giỏ hàng.\n$ kubectl -n ui get service ui-nlb -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[*].hostname}{\u0026#34;\\n\u0026#34;}\u0026#39; k8s-ui-uinlb-647e781087-6717c5049aa96bd9.elb.us-west-2.amazonaws.com Pod carts có thể tiếp cận dịch vụ DynamoDB và giỏ hàng bây giờ có thể truy cập!\nSau khi vai trò IAM của AWS được liên kết với Service Account, bất kỳ Pods mới nào được tạo bằng Service Account đó sẽ bị chặn bởi webhook EKS Pod Identity. Webhook này chạy trên bảng điều khiển của cụm Amazon EKS và được quản lý hoàn toàn bởi AWS. Hãy xem xét kỹ hơn pod carts mới để xem các biến môi trường mới.\n$ kubectl -n carts exec deployment/carts -- env | grep AWS AWS_STS_REGIONAL_ENDPOINTS=regional AWS_DEFAULT_REGION=us-west-2 AWS_REGION=us-west-2 AWS_CONTAINER_CREDENTIALS_FULL_URI=http://169.254.170.23/v1/credentials AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE=/var/run/secrets/pods.eks.amazonaws.com/serviceaccount/eks-pod-identity-token Những điều đáng chú ý là:\nAWS_DEFAULT_REGION Vùng được tự động đặt cùng với cụm EKS của chúng ta AWS_STS_REGIONAL_ENDPOINTS các điểm cuối STS vùng được cấu hình để tránh đặt áp lực quá lớn lên điểm cuối toàn cầu tại us-east-1 Biến AWS_CONTAINER_CREDENTIALS_FULL_URI cho biết cho các SDK của AWS cách lấy thông tin xác thực sử dụng HTTP credential provider. Điều này có nghĩa là EKS Pod Identity không cần phải tiêm thông tin xác thực thông qua một cặp AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY, và thay vào đó các SDK có thể có thông tin xác thực tạm thời được cung cấp cho họ thông qua cơ chế EKS Pod Identity. Bạn có thể đọc thêm về cách hoạt động này trong tài liệu AWS. Bạn đã thành công cấu hình Pod Identity trong Ứng dụng của bạn!!!\n"
},
{
	"uri": "//localhost:1313/vi/6-amazon-guardduty-for-eks/",
	"title": "Amazon GuardDuty for EKS",
	"tags": [],
	"description": "",
	"content": "Amazon GuardDuty for EKS Chuẩn bị môi trường của bạn cho phần này:\n$ prepare-environment Amazon GuardDuty cung cấp các tính năng phát hiện mối đe dọa cho phép bạn liên tục giám sát và bảo vệ các tài khoản AWS, khối lượng công việc và dữ liệu được lưu trữ trong Amazon Simple Storage Service (Amazon S3). GuardDuty phân tích các luồng siêu dữ liệu liên tục được tạo ra từ hoạt động của tài khoản và mạng trong AWS CloudTrail Events, Amazon Virtual Private Cloud (VPC) Flow Logs, và các bản ghi DNS (Domain Name System). GuardDuty cũng sử dụng thông tin tình báo mối đe dọa tích hợp như các địa chỉ IP độc hại đã biết, phát hiện bất thường và học máy (ML) để xác định mối đe dọa một cách chính xác hơn.\nAmazon GuardDuty giúp bạn dễ dàng giám sát liên tục các tài khoản AWS, khối lượng công việc và dữ liệu được lưu trữ trong Amazon S3. GuardDuty hoạt động hoàn toàn độc lập với các tài nguyên của bạn, vì vậy không có rủi ro về hiệu suất hoặc ảnh hưởng đến sẵn có đối với khối lượng công việc của bạn. Dịch vụ được quản lý hoàn toàn và được tích hợp thông tin tình báo mối đe dọa, phát hiện bất thường và ML. Amazon GuardDuty cung cấp các cảnh báo chi tiết và hữu ích dễ tích hợp với các hệ thống quản lý sự kiện và luồng công việc hiện có. Không có chi phí ban đầu và bạn chỉ trả tiền cho các sự kiện được phân tích, không cần triển khai phần mềm bổ sung hoặc đăng ký dịch vụ thông tin tình báo mối đe dọa.\nGuardDuty có hai loại bảo vệ cho EKS:\nEKS Audit Log Monitoring giúp bạn phát hiện các hoạt động đáng ngờ trong các cụm EKS của bạn bằng cách sử dụng hoạt động nhật ký kiểm toán Kubernetes EKS Runtime Monitoring cung cấp phạm vi phát hiện mối đe dọa thời gian chạy cho các nút Amazon Elastic Kubernetes Service (Amazon EKS) và các container trong môi trường AWS của bạn Trong phần này, chúng ta sẽ xem xét cả hai loại bảo vệ với các ví dụ thực tế.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.6--authorization/",
	"title": "Cấp quyền (Authorization)",
	"tags": [],
	"description": "",
	"content": "Cấp quyền (Authorization) Kubernetes hỗ trợ một số cơ chế cấp quyền khác nhau, bao gồm: Node Authorization (Xác thực node) Xác thực dựa trên thuộc tính (Attribute-based Authorization - ABAC) Xác thực dựa trên vai trò (Role-Based Authorization - RBAC) Webhook K8s Reference Docs https://kubernetes.io/docs/reference/access-authn-authz/authorization/ "
},
{
	"uri": "//localhost:1313/vi/7-pod-security-standards/",
	"title": "Hồ sơ PSS bị hạn chế",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị môi trường của bạn cho phần này: $ prepare-environment security/pss-psa :::\nViệc áp dụng Kubernetes một cách an toàn bao gồm việc ngăn chặn các thay đổi không mong muốn vào các cụm. Các thay đổi không mong muốn có thể làm gián đoạn hoạt động của cụm, hành vi công việc và thậm chí làm nguy hiểm tính toàn vẹn của môi trường. Giới thiệu Pods thiếu cấu hình bảo mật chính xác là một ví dụ về một thay đổi không mong muốn vào cụm. Để kiểm soát bảo mật Pods, Kubernetes cung cấp Pod Security Policy / PSP tài nguyên. PSPs chỉ định một bộ cài đặt bảo mật mà Pods phải đáp ứng trước khi chúng có thể được tạo hoặc cập nhật trong một cụm. Tuy nhiên, từ phiên bản Kubernetes 1.21, PSPs đã bị loại bỏ và được lên lịch loại bỏ hoàn toàn trong phiên bản Kubernetes 1.25.\nTrong Kubernetes, PSPs đang được thay thế bằng Pod Security Admission / PSA, một bộ kiểm soát thẩm định tích hợp triển khai các điều khiển bảo mật được mô tả trong Pod Security Standards / PSS. Kể từ phiên bản Kubernetes 1.23, PSA và PSS đều đã đạt được trạng thái tính năng beta và được kích hoạt mặc định trong Dịch vụ Kubernetes Đàn Elastic của Amazon (EKS).\nTiêu Chuẩn Bảo Mật Pod (PSS) và Kiểm Soát Thẩm Định Bảo Mật Pod (PSA) Theo tài liệu Kubernetes, PSS \u0026ldquo;xác định ba chính sách khác nhau để phủ rộng phổ bảo mật. Các chính sách này tích lũy và biến đổi từ rất cho phép đến hạn chế rất cao.\u0026rdquo;\nCác cấp độ chính sách được xác định như sau:\nĐặc Quyền: Chính sách không giới hạn (không an toàn), cung cấp mức độ quyền rộng nhất có thể. Chính sách này cho phép các sự nâng cấp đặc quyền đã biết. Đây là sự vắng mặt của một chính sách. Điều này phù hợp cho các ứng dụng như các đại lý nhật ký, CNIs, các trình điều khiển lưu trữ và các ứng dụng phổ biến khác cần truy cập đặc quyền. Cơ Bản: Chính sách hạn chế tối thiểu ngăn chặn các sự nâng cấp đặc quyền đã biết. Cho phép cấu hình Pods mặc định (được chỉ định tối thiểu). Chính sách cơ bản ngăn chặn việc sử dụng hostNetwork, hostPID, hostIPC, hostPath, hostPort, khả năng thêm quyền Linux, cùng với một số hạn chế khác. Hạn Chế: Chính sách hạn chế nặng, tuân thủ các thực hành tốt nhất hiện tại về cứng cụm Pod. Chính sách này kế thừa từ cấu hình cơ bản và thêm các hạn chế khác như không thể chạy dưới dạng root hoặc root-group. Các chính sách hạn chế có thể ảnh hưởng đến khả năng hoạt động của một ứng dụng. Chúng chủ yếu được dành cho các ứng dụng quan trọng về bảo mật. Bộ kiểm soát thẩm định PSA triển khai các điều khiển, được mô tả bởi các chính sách PSS, qua ba chế độ hoạt động được liệt kê dưới đây.\nthực thi: Vi phạm chính sách sẽ khiến Pods bị từ chối. kiểm tra: Vi phạm chính sách sẽ gây ra việc thêm chú thích kiểm tra vào sự kiện được ghi lại trong bản ghi kiểm tra, nhưng nó vẫn được phép. cảnh báo: Vi phạm chính sách sẽ gây ra một cảnh báo phù hợp với người dùng, nhưng vẫn được phép. Kiểm Soát Thẩm Định Bảo Mật Pods (PSA) tích hợp sẵn Từ phiên bản Kubernetes 1.23, Cổng tính năng PodSecurity gate được kích hoạt mặc định trong Dịch vụ Kubernetes Đàn Elastic của Amazon. Các cài đặt mặc định của PSS và PSA cho phiên bản Kubernetes 1.23 từ nguồn\ngốc cũng được sử dụng cho Dịch vụ Kubernetes Đàn Elastic của Amazon, như được liệt kê dưới đây.\nCổng tính năng PodSecurity đang ở phiên bản Beta (apiVersion: v1beta1) trên Kubernetes v1.23 và v1.24, và trở thành Có Sẵn Một Cách Chính Thức (GA, apiVersion: v1) trong Kubernetes v1.25.\ndefaults: enforce: \u0026#34;privileged\u0026#34; enforce-version: \u0026#34;latest\u0026#34; audit: \u0026#34;privileged\u0026#34; audit-version: \u0026#34;latest\u0026#34; warn: \u0026#34;privileged\u0026#34; warn-version: \u0026#34;latest\u0026#34; exemptions: # Mảng các tên người dùng xác thực được miễn. usernames: [] # Mảng các tên lớp thời gian chạy được miễn. runtimeClasses: [] # Mảng các không gian tên được miễn. namespaces: [] Các cài đặt trên cấu hình kịch bản toàn cụm như sau:\nKhông có các miễn trừ PSA được cấu hình khi khởi động máy chủ API Kubernetes. Hồ sơ PSS Đặc quyền được cấu hình theo mặc định cho tất cả các chế độ PSA, và được đặt thành các phiên bản mới nhất. Nhãn Kiểm Soát Thẩm Định Bảo Mật Pods (PSA) cho Namespaces Dựa trên cấu hình mặc định trên, bạn phải cấu hình các hồ sơ PSS cụ thể và các chế độ PSA tại cấp độ Kubernetes Namespace, để lựa chọn Namespaces vào Pod security được cung cấp bởi PSA và PSS. Bạn có thể cấu hình Namespaces để xác định chế độ kiểm soát thẩm định bạn muốn sử dụng cho bảo mật Pods. Với nhãn Kubernetes, bạn có thể chọn một trong các cấp độ PSS được xác định trước mà bạn muốn sử dụng cho Pods trong một Namespace cụ thể. Nhãn bạn chọn xác định hành động mà PSA thực hiện nếu phát hiện ra vi phạm tiềm ẩn. Như dưới đây, bạn có thể cấu hình bất kỳ hoặc tất cả các chế độ, hoặc thậm chí đặt một cấp độ khác nhau cho các chế độ khác nhau. Đối với mỗi chế độ, có hai nhãn có thể xác định chính sách được sử dụng.\n# Nhãn cấp độ theo từng chế độ chỉ ra cấp độ chính sách được áp dụng cho chế độ đó.\r#\r# CHẾ ĐỘ phải là một trong các giá trị `enforce`, `audit`, hoặc `warn`.\r# CẤP ĐỘ phải là một trong các giá trị `privileged`, `baseline`, hoặc `restricted`.\r*pod-security.kubernetes.io/\u0026lt;CHẾ ĐỘ\u0026gt;*: \u0026lt;CẤP ĐỘ\u0026gt;\r# Tùy chọn: nhãn phiên bản theo chế độ có thể được sử dụng để ghim chính sách vào\r# phiên bản đã được gửi kèm với một phiên bản nhỏ Kubernetes cụ thể (ví dụ: v1.24).\r#\r# CHẾ ĐỘ phải là một trong các giá trị `enforce`, `audit`, hoặc `warn`.\r# PHIÊN BẢN phải là một phiên bản Kubernetes hợp lệ, hoặc `latest`.\r*pod-security.kubernetes.io/\u0026lt;CHẾ ĐỘ\u0026gt;-version*: \u0026lt;PHIÊN BẢN\u0026gt; Dưới đây là một ví dụ về cấu hình Namespaces PSA và PSS có thể được sử dụng cho kiểm tra. Lưu ý rằng chúng tôi không bao gồm nhãn tùy chọn chế độ phiên bản PSA. Chúng tôi đã sử dụng cài đặt toàn cụm, mới nhất, được cấu hình mặc định. Bằng cách gỡ bỏ các nhãn mong muốn, bên dưới, bạn có thể kích hoạt các chế độ PSA và các hồ sơ PSS mà bạn cần cho Namespaces tương ứng của bạn.\napiVersion: v1 kind: Namespace metadata: name: psa-pss-test-ns labels: # pod-security.kubernetes.io/enforce: privileged # pod-security.kubernetes.io/audit: privileged # pod-security.kubernetes.io/warn: privileged # pod-security.kubernetes.io/enforce: baseline # pod-security.kubernetes.io/audit: baseline # pod-security.kubernetes.io/warn: baseline # pod-security.kubernetes.io/enforce: restricted # pod-security.kubernetes.io/audit: restricted # pod-security.kubernetes.io/warn: restricted Xác Thực Kiểm Soát Thẩm Định Trong Kubernetes, một Kiểm Soát Thẩm Định là một phần mã nguồn mở được viết để ngăn chặn các yêu cầu đến máy chủ API Kubernetes trước khi chúng được lưu trữ vào etcd, và được sử dụng để thực hiện các thay đổi trên cụm. Kiểm Soát Thẩm Định có thể là loại biến đổi, xác thực, hoặc cả hai. Việc triển khai PSA là một bộ kiểm soát thẩm định xác thực, và nó kiểm tra các yêu cầu mô tả Pods\nđến để đảm bảo tuân thủ với các PSS cụ thể đã được chỉ định.\nTrong luồng dưới đây, kiểm soát thẩm định động biến đổi và xác thực, được gọi là webhooks kiểm soát thẩm định, được tích hợp vào luồng yêu cầu máy chủ API Kubernetes, thông qua webhooks. Các webhooks gọi ra các dịch vụ, được cấu hình để phản hồi với một số loại yêu cầu máy chủ API nhất định. Ví dụ, bạn có thể sử dụng webhooks để cấu hình các kiểm soát thẩm định động để xác thực rằng các container trong một Pod đang chạy dưới dạng người dùng không phải root, hoặc các container được cung cấp từ các kho lưu trữ đáng tin cậy.\nSử Dụng PSA và PSS PSA thực thi các chính sách được mô tả trong PSS, và các chính sách PSS xác định một bộ hồ sơ bảo mật Pods. Trong biểu đồ dưới đây, chúng tôi mô tả cách PSA và PSS hoạt động cùng nhau, với Pods và Namespaces, để xác định các hồ sơ bảo mật Pods và áp dụng kiểm soát thẩm định dựa trên các hồ sơ đó. Như thấy trong biểu đồ dưới đây, các chế độ thực thi PSA và các chính sách PSS được xác định dưới dạng nhãn trong Namespaces đích.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.7-rbac/",
	"title": "RBAC",
	"tags": [],
	"description": "",
	"content": "RBAC Trong phần này, chúng ta sẽ tìm hiểu về RBAC\nLàm thế nào để tạo một vai trò? Mỗi vai trò có 3 phần apiGroups resources verbs Tạo vai trò bằng lệnh kubectl $ kubectl create -f developer-role.yaml Bước tiếp theo là liên kết người dùng với vai trò đó. Đối với điều này, chúng ta tạo một đối tượng khác được gọi là RoleBinding. Đối tượng liên kết vai trò này liên kết một đối tượng người dùng với một vai trò. Tạo liên kết vai trò bằng lệnh kubectl $ kubectl create -f devuser-developer-binding.yaml Cũng lưu ý rằng các vai trò và liên kết vai trò nằm trong phạm vi của namespace. apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: developer rules: - apiGroups: [\u0026#34;\u0026#34;] # \u0026#34;\u0026#34; biểu thị nhóm API cốt lõi resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;create\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;ConfigMap\u0026#34;] verbs: [\u0026#34;create\u0026#34;] apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: devuser-developer-binding subjects: - kind: User name: dev-user # \u0026#34;name\u0026#34; phân biệt chữ hoa chữ thường apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: developer apiGroup: rbac.authorization.k8s.io Xem RBAC Để liệt kê các vai trò\n$ kubectl get roles Để liệt kê các liên kết vai trò\n$ kubectl get rolebindings Để mô tả vai trò\n$ kubectl describe role developer Để mô tả liên kết vai trò\n$ kubectl describe rolebinding devuser-developer-binding Nếu bạn là một người dùng muốn xem, liệu bạn có quyền truy cập vào một tài nguyên cụ thể trong cluster không?\nKiểm tra quyền truy cập Bạn có thể sử dụng lệnh kubectl auth $ kubectl auth can-i create deployments $ kubectl auth can-i delete nodes $ kubectl auth can-i create deployments --as dev-user $ kubectl auth can-i create pods --as dev-user $ kubectl auth can-i create pods --as dev-user --namespace test Tên Tài Nguyên Lưu ý về tên tài nguyên, chúng ta vừa thấy cách bạn có thể cung cấp quyền truy cập cho người dùng đối với các tài nguyên như pods trong namespace. apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: developer rules: - apiGroups: [\u0026#34;\u0026#34;] # \u0026#34;\u0026#34; biểu thị nhóm API cốt lõi resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;create\u0026#34;] resourceNames: [\u0026#34;blue\u0026#34;, \u0026#34;orange\u0026#34;] Tài liệu Tham Khảo K8s https://kubernetes.io/docs/reference/access-authn-authz/rbac/ https://kubernetes.io/docs/reference/access-authn-authz/rbac/#command-line-utilities "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.8-cluster-roles/",
	"title": "Cluster Roles",
	"tags": [],
	"description": "",
	"content": "Cluster Roles Trong phần này, chúng ta sẽ tìm hiểu về các vai trò cụm\nRole (Vai trò) Vai trò và Rolebindings được gắn với không gian tên, có nghĩa là chúng được tạo trong các không gian tên. Namespace (Không gian tên) Bạn có thể nhóm hoặc cô lập các nút trong một không gian tên không?\nKhông, những thứ đó là tài nguyên phạm vi cụm hoặc phạm vi cụm. Chúng không thể được liên kết với bất kỳ không gian tên cụ thể nào. Vì vậy, các tài nguyên được phân loại là tài nguyên phạm vi tên hoặc phạm vi cụm.\nĐể xem tài nguyên phạm vi tên\n$ kubectl api-resources --namespaced=true Để xem tài nguyên không phạm vi tên\n$ kubectl api-resources --namespaced=false ClusterRole (Vai trò cụm) và ClusterRoleBinding (Ràng buộc Vai trò cụm) Vai trò cụm là các vai trò ngoại trừ chúng được sử dụng cho các tài nguyên phạm vi cụm. Loại như CLusterRole\napiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-administrator rules: - apiGroups: [\u0026#34;\u0026#34;] # \u0026#34;\u0026#34; chỉ ra nhóm API lõi resources: [\u0026#34;nodes\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;create\u0026#34;] apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-admin-role-binding subjects: - kind: User name: cluster-admin apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-administrator apiGroup: rbac.authorization.k8s.io $ kubectl create -f cluster-admin-role.yaml $ kubectl create -f cluster-admin-role-binding.yaml Bạn cũng có thể tạo một vai trò cụm cho các tài nguyên không gian tên. Khi bạn làm điều đó, người dùng sẽ có quyền truy cập vào các tài nguyên này trên tất cả các không gian tên.\nTài liệu Tham khảo K8s https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole https://kubernetes.io/docs/reference/access-authn-authz/rbac/#command-line-utilities "
},
{
	"uri": "//localhost:1313/vi/8-policy-management-with-kyverno/",
	"title": "Policy management with Kyverno",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị môi trường cho phần này: $ prepare-environment security/kyverno Điều này sẽ thực hiện các thay đổi sau đây cho môi trường lab của bạn:\nCài đặt các add-on Kubernetes sau trong cụm EKS:\nQuản lý Chính sách Kyverno Các Chính sách Kyverno Báo cáo Chính sách Bạn có thể xem Terraform áp dụng các thay đổi này tại đây. :::\nKhi các container được sử dụng rộng rãi trong môi trường sản xuất, các nhóm DevOps, Bảo mật và Nền tảng cần một giải pháp để hợp tác và quản lý Quản trị và Chính sách-dưới-dạng-Mã (PaC). Điều này đảm bảo rằng tất cả các nhóm khác nhau đều có thể có cùng một nguồn tin cậy trong việc đảm bảo bảo mật, cũng như sử dụng cùng một \u0026ldquo;ngôn ngữ\u0026rdquo; cơ bản khi mô tả các nhu cầu cá nhân của họ.\nKubernetes theo bản chất của nó được thiết kế để là một công cụ để xây dựng và điều phối, điều này có nghĩa là nó thiếu các rào cản được xác định trước. Để cung cấp cho các nhà xây dựng một cách để kiểm soát bảo mật, Kubernetes cung cấp (bắt đầu từ phiên bản 1.23) Pod Security Admission (PSA), một bộ kiểm soát đăng ký tích hợp mà thực hiện các điều khiển bảo mật được mô tả trong Tiêu chuẩn Bảo mật Pod (PSS), được kích hoạt mặc định trong Dịch vụ Amazon Elastic Kubernetes (EKS).\nKyverno là gì Kyverno (tiếng Hy Lạp có nghĩa là \u0026ldquo;quản trị\u0026rdquo;) là một công cụ đặc biệt được thiết kế cho Kubernetes. Đó là một dự án của Cloud Native Computing Foundation (CNCF) cho phép các nhóm hợp tác và thực thi Chính sách-dưới-dạng-Mã.\nBộ động lực chính của Kyverno tích hợp với máy chủ API Kubernetes như Bộ kiểm soát Đăng ký Động, cho phép các chính sách biến đổi và xác nhận các yêu cầu API Kubernetes đến, đảm bảo tuân thủ với các quy tắc được xác định trước trước khi dữ liệu được lưu trữ và cuối cùng được áp dụng vào cụm.\nKyverno cho phép các nguồn tài nguyên Kubernetes mô tả theo cách khai báo viết bằng YAML, không cần học ngôn ngữ chính sách mới, và kết quả có sẵn dưới dạng các nguồn tài nguyên Kubernetes và sự kiện.\nCác chính sách Kyverno có thể được sử dụng để xác nhận, biến đổi, và tạo ra cấu hình tài nguyên, cũng như xác nhận chữ ký hình ảnh và giấy chứng nhận, cung cấp tất cả các khối xây dựng cần thiết cho việc thực thi các tiêu chuẩn bảo mật chuỗi cung ứng phần mềm hoàn chỉnh.\nCách làm việc của Kyverno Như đã đề cập ở trên, Kyverno chạy như một Bộ kiểm soát Đăng ký Động trong một Cụm Kubernetes. Kyverno nhận các cuộc gọi webhook HTTP xác nhận và biến đổi từ máy chủ API Kubernetes và áp dụng các chính sách phù hợp để trả lại kết quả thực thi chính sách hoặc từ chối các yêu cầu. Nó cũng có thể được sử dụng để Kiểm tra các yêu cầu và theo dõi tư duy Bảo mật của môi trường trước khi thực thi.\nBiểu đồ dưới đây hiển thị kiến trúc logic cấp cao của Kyverno.\nHai thành phần chính là Máy chủ Webhook \u0026amp; Bộ điều khiển Webhook. Máy chủ Webhook xử lý các yêu cầu AdmissionReview đến từ máy chủ API Kubernetes và gửi chúng đến Engine để xử lý. Nó được cấu hình động bởi Bộ điều khiển Webhook theo dõi các chính sách được cài đặt và sửa đổi các webhook để yêu cầu chỉ các tài nguyên phù hợp với các chính sách đó.\nTrước khi tiếp tục với các lab, xác thực các tài nguyên Kyverno được cung cấp bởi t\nập lệnh prepare-environment.\n$ kubectl -n kyverno get all NAME READY STATUS RESTARTS AGE pod/kyverno-admission-controller-594c99487b-wpnsr 1/1 Running 0 8m15s pod/kyverno-background-controller-7547578799-ltg7f 1/1 Running 0 8m15s pod/kyverno-cleanup-admission-reports-28314690-6vjn4 0/1 Completed 0 3m20s pod/kyverno-cleanup-cluster-admission-reports-28314690-2jjht 0/1 Completed 0 3m20s pod/kyverno-cleanup-controller-79575cdb59-mlbz2 1/1 Running 0 8m15s pod/kyverno-reports-controller-8668db7759-zxjdh 1/1 Running 0 8m15s pod/policy-reporter-57f7dfc766-n48qk 1/1 Running 0 7m53s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kyverno-background-controller-metrics ClusterIP 172.20.42.104 \u0026lt;none\u0026gt; 8000/TCP 8m16s service/kyverno-cleanup-controller ClusterIP 172.20.25.127 \u0026lt;none\u0026gt; 443/TCP 8m16s service/kyverno-cleanup-controller-metrics ClusterIP 172.20.184.34 \u0026lt;none\u0026gt; 8000/TCP 8m16s service/kyverno-reports-controller-metrics ClusterIP 172.20.84.109 \u0026lt;none\u0026gt; 8000/TCP 8m16s service/kyverno-svc ClusterIP 172.20.157.100 \u0026lt;none\u0026gt; 443/TCP 8m16s service/kyverno-svc-metrics ClusterIP 172.20.36.168 \u0026lt;none\u0026gt; 8000/TCP 8m16s service/policy-reporter ClusterIP 172.20.175.164 \u0026lt;none\u0026gt; 8080/TCP 7m53s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/kyverno-admission-controller 1/1 1 1 8m16s deployment.apps/kyverno-background-controller 1/1 1 1 8m16s deployment.apps/kyverno-cleanup-controller 1/1 1 1 8m16s deployment.apps/kyverno-reports-controller 1/1 1 1 8m16s deployment.apps/policy-reporter 1/1 1 1 7m53s NAME DESIRED CURRENT READY AGE replicaset.apps/kyverno-admission-controller-594c99487b 1 1 1 8m16s replicaset.apps/kyverno-background-controller-7547578799 1 1 1 8m16s replicaset.apps/kyverno-cleanup-controller-79575cdb59 1 1 1 8m16s replicaset.apps/kyverno-reports-controller-8668db7759 1 1 1 8m16s replicaset.apps/policy-reporter-57f7dfc766 1 1 1 7m53s NAME SCHEDULE SUSPEND ACTIVE LAST SCHEDULE AGE cronjob.batch/kyverno-cleanup-admission-reports */10 * * * * False 0 3m20s 8m16s cronjob.batch/kyverno-cleanup-cluster-admission-reports */10 * * * * False 0 3m20s 8m16s NAME COMPLETIONS DURATION AGE job.batch/kyverno-cleanup-admission-reports-28314690 1/1 13s 3m20s job.batch/kyverno-cleanup-cluster-admission-reports-28314690 1/1 10s 3m20s "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.9-image-security/",
	"title": "Image Security",
	"tags": [],
	"description": "",
	"content": "Image Security Trong phần này, chúng ta sẽ xem xét về Image Security\nImage Security apiVersion: v1\rkind: Pod\rmetadata:\rname: nginx-pod\rspec:\rcontainers:\r- name: nginx\rimage: nginx Private Registry Để đăng nhập vào registry\n$ docker login private-registry.io Chạy ứng dụng bằng hình ảnh có sẵn tại registry riêng tư\n$ docker run private-registry.io/apps/internal-app Để truyền thông tin xác thực cho docker không được gắn nhãn trên nút làm việc, trước tiên chúng ta tạo một đối tượng bí mật chứa thông tin xác thực.\n$ kubectl create secret docker-registry regcred \\ --docker-server=private-registry.io \\ --docker-username=registry-user \\ --docker-password=registry-password \\ --docker-email=registry-user@org.com Sau đó, chúng ta chỉ định bí mật trong tệp định nghĩa pod của chúng ta trong phần imagePullSecret\napiVersion: v1\rkind: Pod\rmetadata:\rname: nginx-pod\rspec:\rcontainers:\r- name: nginx\rimage: private-registry.io/apps/internal-app\rimagePullSecrets:\r- name: regcred Tài Liệu Tham Khảo K8s https://kubernetes.io/docs/concepts/containers/images/ "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.10-security-context/",
	"title": "Security-Context",
	"tags": [],
	"description": "",
	"content": "Security-Context Bảo mật Ngữ cảnh Trong phần này, chúng ta sẽ xem xét về bảo mật ngữ cảnh\nBảo mật Container $ docker run --user=1001 ubuntu sleep 3600\r$ docker run -cap-add MAC_ADMIN ubuntu Bảo mật Kubernetes Bạn có thể chọn cấu hình các thiết lập bảo mật ở mức container hoặc mức pod. Ngữ cảnh Bảo mật Để thêm ngữ cảnh bảo mật vào container và một trường gọi là securityContext dưới phần spec.\napiVersion: v1\rkind: Pod\rmetadata:\rname: web-pod\rspec:\rsecurityContext:\rrunAsUser: 1000\rcontainers:\r- name: ubuntu\rimage: ubuntu\rcommand: [\u0026#34;sleep\u0026#34;, \u0026#34;3600\u0026#34;] Để đặt cùng một ngữ cảnh ở mức container, sau đó di chuyển toàn bộ phần dưới mục container.\napiVersion: v1\rkind: Pod\rmetadata:\rname: web-pod\rspec:\rcontainers:\r- name: ubuntu\rimage: ubuntu\rcommand: [\u0026#34;sleep\u0026#34;, \u0026#34;3600\u0026#34;]\rsecurityContext:\rrunAsUser: 1000 Để thêm khả năng sử dụng tùy chọn capabilities\napiVersion: v1\rkind: Pod\rmetadata:\rname: web-pod\rspec:\rcontainers:\r- name: ubuntu\rimage: ubuntu\rcommand: [\u0026#34;sleep\u0026#34;, \u0026#34;3600\u0026#34;]\rsecurityContext:\rrunAsUser: 1000\rcapabilities: add: [\u0026#34;MAC_ADMIN\u0026#34;] Tài liệu Tham khảo K8s https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.11-network-policies/",
	"title": "Network-Policies (Chính sách Mạng)",
	"tags": [],
	"description": "",
	"content": "Lưu lượng đi qua một máy chủ web frontend cho người dùng một máy chủ ứng dụng phục vụ API phía sau và một máy chủ cơ sở dữ liệu.\nCó hai loại lưu lượng Ingress Egress Bảo mật Mạng Chính sách Mạng Bộ chọn Chính sách Mạng Quy tắc Chính sách Mạng Tạo chính sách mạng Để tạo một chính sách mạng\napiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: db-policy spec: podSelector: matchLabels: role: db policyTypes: - Ingress ingress: - from: - podSelector: matchLabels: role: api-pod ports: - protocol: TCP port: 3306 $ kubectl create -f policy-definition.yaml Ghi chú Bài giảng bổ sung về Phát triển Chính sách Mạng Tài liệu Tham khảo K8s https://kubernetes.io/docs/concepts/services-networking/network-policies/ https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/ "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]